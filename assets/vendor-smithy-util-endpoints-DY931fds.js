import{E as e}from"./vendor-smithy-types-CI1XBBMP.js";class r{constructor({size:e,params:r}){this.data=new Map,this.parameters=[],this.capacity=e??50,r&&(this.parameters=r)}get(e,r){const t=this.hash(e);if(!1===t)return r();if(!this.data.has(t)){if(this.data.size>this.capacity+10){const e=this.data.keys();let r=0;for(;;){const{value:t,done:n}=e.next();if(this.data.delete(t),n||++r>10)break}}this.data.set(t,r())}return this.data.get(t)}size(){return this.data.size}hash(e){let r="";const{parameters:t}=this;if(0===t.length)return!1;for(const n of t){const t=String(e[n]??"");if(t.includes("|;"))return!1;r+=t+"|;"}return r}}const t=new RegExp("^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$"),n=e=>t.test(e)||e.startsWith("[")&&e.endsWith("]"),s=new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$"),o=(e,r=!1)=>{if(!r)return s.test(e);const t=e.split(".");for(const n of t)if(!o(n))return!1;return!0},i={},a="endpoints";function c(e){return"object"!=typeof e||null==e?e:"ref"in e?`$${c(e.ref)}`:"fn"in e?`${e.fn}(${(e.argv||[]).map(c).join(", ")})`:JSON.stringify(e,null,2)}class u extends Error{constructor(e){super(e),this.name="EndpointError"}}const l=(e,r)=>(e=>{const r=e.split("."),t=[];for(const n of r){const r=n.indexOf("[");if(-1!==r){if(n.indexOf("]")!==n.length-1)throw new u(`Path: '${e}' does not end with ']'`);const s=n.slice(r+1,-1);if(Number.isNaN(parseInt(s)))throw new u(`Invalid array index: '${s}' in path: '${e}'`);0!==r&&t.push(n.slice(0,r)),t.push(s)}else t.push(n)}return t})(r).reduce((t,n)=>{if("object"!=typeof t)throw new u(`Index '${n}' in '${r}' not found in '${JSON.stringify(e)}'`);return Array.isArray(t)?t[parseInt(n)]:t[n]},e),f={[e.HTTP]:80,[e.HTTPS]:443},d={booleanEquals:(e,r)=>e===r,getAttr:l,isSet:e=>null!=e,isValidHostLabel:o,not:e=>!e,parseURL:r=>{const t=(()=>{try{if(r instanceof URL)return r;if("object"==typeof r&&"hostname"in r){const{hostname:e,port:t,protocol:n="",path:s="",query:o={}}=r,i=new URL(`${n}//${e}${t?`:${t}`:""}${s}`);return i.search=Object.entries(o).map(([e,r])=>`${e}=${r}`).join("&"),i}return new URL(r)}catch(e){return null}})();if(!t)return null;const s=t.href,{host:o,hostname:i,pathname:a,protocol:c,search:u}=t;if(u)return null;const l=c.slice(0,-1);if(!Object.values(e).includes(l))return null;const d=n(i);return{scheme:l,authority:`${o}${s.includes(`${o}:${f[l]}`)||"string"==typeof r&&r.includes(`${o}:${f[l]}`)?`:${f[l]}`:""}`,path:a,normalizedPath:a.endsWith("/")?a:`${a}/`,isIp:d}},stringEquals:(e,r)=>e===r,substring:(e,r,t,n)=>r>=t||e.length<t?null:n?e.substring(e.length-t,e.length-r):e.substring(r,t),uriEncode:e=>encodeURIComponent(e).replace(/[!*'()]/g,e=>`%${e.charCodeAt(0).toString(16).toUpperCase()}`)},p=(e,r)=>{const t=[],n={...r.endpointParams,...r.referenceRecord};let s=0;for(;s<e.length;){const r=e.indexOf("{",s);if(-1===r){t.push(e.slice(s));break}t.push(e.slice(s,r));const o=e.indexOf("}",r);if(-1===o){t.push(e.slice(r));break}"{"===e[r+1]&&"}"===e[o+1]&&(t.push(e.slice(r+1,o)),s=o+2);const i=e.substring(r+1,o);if(i.includes("#")){const[e,r]=i.split("#");t.push(l(n[e],r))}else t.push(n[i]);s=o+1}return t.join("")},h=(e,r,t)=>{if("string"==typeof e)return p(e,t);if(e.fn)return g(e,t);if(e.ref)return(({ref:e},r)=>({...r.endpointParams,...r.referenceRecord}[e]))(e,t);throw new u(`'${r}': ${String(e)} is not a string, function or reference.`)},g=({fn:e,argv:r},t)=>{const n=r.map(e=>["boolean","number"].includes(typeof e)?e:h(e,"arg",t)),s=e.split(".");return s[0]in i&&null!=s[1]?i[s[0]][s[1]](...n):d[e](...n)},$=({assign:e,...r},t)=>{if(e&&e in t.referenceRecord)throw new u(`'${e}' is already defined in Reference Record.`);const n=g(r,t);return t.logger?.debug?.(`${a} evaluateCondition: ${c(r)} = ${c(n)}`),{result:""===n||!!n,...null!=e&&{toAssign:{name:e,value:n}}}},m=(e=[],r)=>{const t={};for(const n of e){const{result:e,toAssign:s}=$(n,{...r,referenceRecord:{...r.referenceRecord,...t}});if(!e)return{result:e};s&&(t[s.name]=s.value,r.logger?.debug?.(`${a} assign: ${s.name} := ${c(s.value)}`))}return{result:!0,referenceRecord:t}},w=(e,r)=>Object.entries(e).reduce((e,[t,n])=>({...e,[t]:n.map(e=>{const n=h(e,"Header value entry",r);if("string"!=typeof n)throw new u(`Header '${t}' value '${n}' is not a string`);return n})}),{}),y=(e,r)=>{if(Array.isArray(e))return e.map(e=>y(e,r));switch(typeof e){case"string":return p(e,r);case"object":if(null===e)throw new u(`Unexpected endpoint property: ${e}`);return R(e,r);case"boolean":return e;default:throw new u("Unexpected endpoint property type: "+typeof e)}},R=(e,r)=>Object.entries(e).reduce((e,[t,n])=>({...e,[t]:y(n,r)}),{}),b=(e,r)=>{const t=h(e,"Endpoint URL",r);if("string"==typeof t)try{return new URL(t)}catch(n){throw n}throw new u("Endpoint URL must be a string, got "+typeof t)},v=(e,r)=>{const{conditions:t,endpoint:n}=e,{result:s,referenceRecord:o}=m(t,r);if(!s)return;const i={...r,referenceRecord:{...r.referenceRecord,...o}},{url:u,properties:l,headers:f}=n;return r.logger?.debug?.(`${a} Resolving endpoint from template: ${c(n)}`),{...null!=f&&{headers:w(f,i)},...null!=l&&{properties:R(l,i)},url:b(u,i)}},j=(e,r)=>{const{conditions:t,error:n}=e,{result:s,referenceRecord:o}=m(t,r);if(s)throw new u(h(n,"Error",{...r,referenceRecord:{...r.referenceRecord,...o}}))},E=(e,r)=>{const{conditions:t,rules:n}=e,{result:s,referenceRecord:o}=m(t,r);if(s)return x(n,{...r,referenceRecord:{...r.referenceRecord,...o}})},x=(e,r)=>{for(const t of e)if("endpoint"===t.type){const e=v(t,r);if(e)return e}else if("error"===t.type)j(t,r);else{if("tree"!==t.type)throw new u(`Unknown endpoint rule: ${t}`);{const e=E(t,r);if(e)return e}}throw new u("Rules evaluation failed")},O=(e,r)=>{const{endpointParams:t,logger:n}=r,{parameters:s,rules:o}=e;r.logger?.debug?.(`${a} Initial EndpointParams: ${c(t)}`);const i=Object.entries(s).filter(([,e])=>null!=e.default).map(([e,r])=>[e,r.default]);if(i.length>0)for(const[a,c]of i)t[a]=t[a]??c;const l=Object.entries(s).filter(([,e])=>e.required).map(([e])=>e);for(const a of l)if(null==t[a])throw new u(`Missing required parameter: '${a}'`);const f=x(o,{endpointParams:t,logger:n,referenceRecord:{}});return r.logger?.debug?.(`${a} Resolved endpoint: ${c(f)}`),f};export{r as E,n as a,i as c,o as i,O as r};
