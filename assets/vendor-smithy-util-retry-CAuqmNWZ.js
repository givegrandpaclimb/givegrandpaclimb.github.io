import{i as t}from"./vendor-smithy-service-error-classification-CFH3_hkI.js";var s,i;(i=s||(s={})).STANDARD="standard",i.ADAPTIVE="adaptive";const h=3,e=s.STANDARD;class r{constructor(t){this.currentCapacity=0,this.enabled=!1,this.lastMaxRate=0,this.measuredTxRate=0,this.requestCount=0,this.lastTimestamp=0,this.timeWindow=0,this.beta=t?.beta??.7,this.minCapacity=t?.minCapacity??1,this.minFillRate=t?.minFillRate??.5,this.scaleConstant=t?.scaleConstant??.4,this.smooth=t?.smooth??.8;const s=this.getCurrentTimeInSeconds();this.lastThrottleTime=s,this.lastTxRateBucket=Math.floor(this.getCurrentTimeInSeconds()),this.fillRate=this.minFillRate,this.maxCapacity=this.minCapacity}getCurrentTimeInSeconds(){return Date.now()/1e3}async getSendToken(){return this.acquireTokenBucket(1)}async acquireTokenBucket(t){if(this.enabled){if(this.refillTokenBucket(),t>this.currentCapacity){const s=(t-this.currentCapacity)/this.fillRate*1e3;await new Promise(t=>r.setTimeoutFn(t,s))}this.currentCapacity=this.currentCapacity-t}}refillTokenBucket(){const t=this.getCurrentTimeInSeconds();if(!this.lastTimestamp)return void(this.lastTimestamp=t);const s=(t-this.lastTimestamp)*this.fillRate;this.currentCapacity=Math.min(this.maxCapacity,this.currentCapacity+s),this.lastTimestamp=t}updateClientSendingRate(s){let i;if(this.updateMeasuredRate(),t(s)){const t=this.enabled?Math.min(this.measuredTxRate,this.fillRate):this.measuredTxRate;this.lastMaxRate=t,this.calculateTimeWindow(),this.lastThrottleTime=this.getCurrentTimeInSeconds(),i=this.cubicThrottle(t),this.enableTokenBucket()}else this.calculateTimeWindow(),i=this.cubicSuccess(this.getCurrentTimeInSeconds());const h=Math.min(i,2*this.measuredTxRate);this.updateTokenBucketRate(h)}calculateTimeWindow(){this.timeWindow=this.getPrecise(Math.pow(this.lastMaxRate*(1-this.beta)/this.scaleConstant,1/3))}cubicThrottle(t){return this.getPrecise(t*this.beta)}cubicSuccess(t){return this.getPrecise(this.scaleConstant*Math.pow(t-this.lastThrottleTime-this.timeWindow,3)+this.lastMaxRate)}enableTokenBucket(){this.enabled=!0}updateTokenBucketRate(t){this.refillTokenBucket(),this.fillRate=Math.max(t,this.minFillRate),this.maxCapacity=Math.max(t,this.minCapacity),this.currentCapacity=Math.min(this.currentCapacity,this.maxCapacity)}updateMeasuredRate(){const t=this.getCurrentTimeInSeconds(),s=Math.floor(2*t)/2;if(this.requestCount++,s>this.lastTxRateBucket){const t=this.requestCount/(s-this.lastTxRateBucket);this.measuredTxRate=this.getPrecise(t*this.smooth+this.measuredTxRate*(1-this.smooth)),this.requestCount=0,this.lastTxRateBucket=s}}getPrecise(t){return parseFloat(t.toFixed(8))}}r.setTimeoutFn=setTimeout;const a="amz-sdk-invocation-id",n="amz-sdk-request",o=({retryDelay:t,retryCount:s,retryCost:i})=>({getRetryCount:()=>s,getRetryDelay:()=>Math.min(2e4,t),getRetryCost:()=>i});class c{constructor(t){this.maxAttempts=t,this.mode=s.STANDARD,this.capacity=500,this.retryBackoffStrategy=(()=>{let t=100;return{computeNextBackoffDelay:s=>Math.floor(Math.min(2e4,Math.random()*2**s*t)),setDelayBase:s=>{t=s}}})(),this.maxAttemptsProvider="function"==typeof t?t:async()=>t}async acquireInitialRetryToken(t){return o({retryDelay:100,retryCount:0})}async refreshRetryTokenForRetry(t,s){const i=await this.getMaxAttempts();if(this.shouldRetry(t,s,i)){const i=s.errorType;this.retryBackoffStrategy.setDelayBase("THROTTLING"===i?500:100);const h=this.retryBackoffStrategy.computeNextBackoffDelay(t.getRetryCount()),e=s.retryAfterHint?Math.max(s.retryAfterHint.getTime()-Date.now()||0,h):h,r=this.getCapacityCost(i);return this.capacity-=r,o({retryDelay:e,retryCount:t.getRetryCount()+1,retryCost:r})}throw new Error("No retry token available")}recordSuccess(t){this.capacity=Math.max(500,this.capacity+(t.getRetryCost()??1))}getCapacity(){return this.capacity}async getMaxAttempts(){try{return await this.maxAttemptsProvider()}catch(t){return 3}}shouldRetry(t,s,i){return t.getRetryCount()+1<i&&this.capacity>=this.getCapacityCost(s.errorType)&&this.isRetryableError(s.errorType)}getCapacityCost(t){return"TRANSIENT"===t?10:5}isRetryableError(t){return"THROTTLING"===t||"TRANSIENT"===t}}class u{constructor(t,i){this.maxAttemptsProvider=t,this.mode=s.ADAPTIVE;const{rateLimiter:h}=i??{};this.rateLimiter=h??new r,this.standardRetryStrategy=new c(t)}async acquireInitialRetryToken(t){return await this.rateLimiter.getSendToken(),this.standardRetryStrategy.acquireInitialRetryToken(t)}async refreshRetryTokenForRetry(t,s){return this.rateLimiter.updateClientSendingRate(s),this.standardRetryStrategy.refreshRetryTokenForRetry(t,s)}recordSuccess(t){this.rateLimiter.updateClientSendingRate({}),this.standardRetryStrategy.recordSuccess(t)}}export{u as A,e as D,a as I,s as R,c as S,h as a,n as b};
