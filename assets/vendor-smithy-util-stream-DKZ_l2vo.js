import{f as e,t}from"./vendor-smithy-util-base64-BxOL2JNu.js";import{f as r,t as n}from"./vendor-smithy-util-utf8-MtSxxKG8.js";import{t as s}from"./vendor-smithy-util-hex-encoding-DhdgocZN.js";import{s as a}from"./vendor-smithy-fetch-http-handler-PV8rLvob.js";class o extends Uint8Array{static fromString(t,n="utf-8"){if("string"==typeof t)return"base64"===n?o.mutate(e(t)):o.mutate(r(t));throw new Error(`Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`)}static mutate(e){return Object.setPrototypeOf(e,o.prototype),e}transformToString(e="utf-8"){return"base64"===e?t(this):n(this)}}const i="function"==typeof ReadableStream?ReadableStream:function(){};class c extends i{}const u=e=>"function"==typeof ReadableStream&&(e?.constructor?.name===ReadableStream.name||e instanceof ReadableStream),f=({expectedChecksum:e,checksum:r,source:n,checksumSourceLocation:s,base64Encoder:a})=>{if(!u(n))throw new Error(`@smithy/util-stream: unsupported source type ${n?.constructor?.name??n} in ChecksumStream.`);const o=a??t;if("function"!=typeof TransformStream)throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");const i=new TransformStream({start(){},async transform(e,t){r.update(e),t.enqueue(e)},async flush(t){const n=await r.digest(),a=o(n);if(e!==a){const r=new Error(`Checksum mismatch: expected "${e}" but received "${a}" in response header "${s}".`);t.error(r)}else t.terminate()}});n.pipeThrough(i);const f=i.readable;return Object.setPrototypeOf(f,c.prototype),f};class h{allocByteArray;byteLength=0;byteArrays=[];constructor(e){this.allocByteArray=e}push(e){this.byteArrays.push(e),this.byteLength+=e.byteLength}flush(){if(1===this.byteArrays.length){const e=this.byteArrays[0];return this.reset(),e}const e=this.allocByteArray(this.byteLength);let t=0;for(let r=0;r<this.byteArrays.length;++r){const n=this.byteArrays[r];e.set(n,t),t+=n.byteLength}return this.reset(),e}reset(){this.byteArrays=[],this.byteLength=0}}const l=function(e,t,r){const n=e.getReader();let s=!1,a=0;const o=["",new h(e=>new Uint8Array(e))];let i=-1;const c=async e=>{const{value:u,done:f}=await n.read(),h=u;if(f){if(-1!==i){const t=m(o,i);y(t)>0&&e.enqueue(t)}e.close()}else{const n=function(e,t=!0){return t&&"undefined"!=typeof Buffer&&e instanceof Buffer?2:e instanceof Uint8Array?1:"string"==typeof e?0:-1}(h,!1);if(i!==n&&(i>=0&&e.enqueue(m(o,i)),i=n),-1===i)return void e.enqueue(h);const u=y(h);a+=u;const f=y(o[i]);if(u>=t&&0===f)e.enqueue(h);else{const n=function(e,t,r){switch(t){case 0:return e[0]+=r,y(e[0]);case 1:case 2:return e[t].push(r),y(e[t])}}(o,i,h);!s&&a>2*t&&(s=!0,r?.warn(`@smithy/util-stream - stream chunk size ${u} is below threshold of ${t}, automatically buffering.`)),n>=t?e.enqueue(m(o,i)):await c(e)}}};return new ReadableStream({pull:c})};function m(e,t){switch(t){case 0:const r=e[0];return e[0]="",r;case 1:case 2:return e[t].flush()}throw new Error(`@smithy/util-stream - invalid index ${t} given to flush()`)}function y(e){return e?.byteLength??e?.length??0}const d=(e,t)=>{const{base64Encoder:r,bodyLengthChecker:n,checksumAlgorithmFn:s,checksumLocationName:a,streamHasher:o}=t,i=void 0!==r&&void 0!==n&&void 0!==s&&void 0!==a&&void 0!==o,c=i?o(s,e):void 0,u=e.getReader();return new ReadableStream({async pull(e){const{value:t,done:s}=await u.read();if(s){if(e.enqueue("0\r\n"),i){const t=r(await c);e.enqueue(`${a}:${t}\r\n`),e.enqueue("\r\n")}e.close()}else e.enqueue(`${(n(t)||0).toString(16)}\r\n${t}\r\n`)}})};async function b(e,t){let r=0;const n=[],s=e.getReader();let a=!1;for(;!a;){const{done:e,value:o}=await s.read();if(o&&(n.push(o),r+=o?.byteLength??0),r>=t)break;a=e}s.releaseLock();const o=new Uint8Array(Math.min(t,r));let i=0;for(const c of n){if(c.byteLength>o.byteLength-i){o.set(c.subarray(0,o.byteLength-i),i);break}o.set(c,i),i+=c.length}return o}const p="The stream has already been transformed.",w=e=>{if(!g(e)&&!u(e))throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${e?.__proto__?.constructor?.name||e}`);let r=!1;const o=async()=>{if(r)throw new Error(p);return r=!0,await a(e)};return Object.assign(e,{transformToByteArray:o,transformToString:async e=>{const r=await o();if("base64"===e)return t(r);if("hex"===e)return s(r);if(void 0===e||"utf8"===e||"utf-8"===e)return n(r);if("function"==typeof TextDecoder)return new TextDecoder(e).decode(r);throw new Error("TextDecoder is not available, please make sure polyfill is provided.")},transformToWebStream:()=>{if(r)throw new Error(p);if(r=!0,g(e))return(e=>{if("function"!=typeof e.stream)throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\nIf you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");return e.stream()})(e);if(u(e))return e;throw new Error(`Cannot transform payload to web stream, got ${e}`)}})},g=e=>"function"==typeof Blob&&e instanceof Blob;async function v(e){return"function"==typeof e.stream&&(e=e.stream()),e.tee()}export{o as U,f as a,v as b,l as c,d as g,b as h,w as s};
