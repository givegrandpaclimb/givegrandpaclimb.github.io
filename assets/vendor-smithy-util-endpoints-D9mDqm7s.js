import{E as e}from"./vendor-smithy-types-CI1XBBMP.js";class r{constructor({size:e,params:r}){this.data=new Map,this.parameters=[],this.capacity=e??50,r&&(this.parameters=r)}get(e,r){const t=this.hash(e);if(!1===t)return r();if(!this.data.has(t)){if(this.data.size>this.capacity+10){const e=this.data.keys();let r=0;for(;;){const{value:t,done:n}=e.next();if(this.data.delete(t),n||++r>10)break}}this.data.set(t,r())}return this.data.get(t)}size(){return this.data.size}hash(e){let r="";const{parameters:t}=this;if(0===t.length)return!1;for(const n of t){const t=String(e[n]??"");if(t.includes("|;"))return!1;r+=t+"|;"}return r}}const t=new RegExp("^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$"),n=e=>t.test(e)||e.startsWith("[")&&e.endsWith("]"),o=new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$"),s=(e,r=!1)=>{if(!r)return o.test(e);const t=e.split(".");for(const n of t)if(!s(n))return!1;return!0},i={},c="endpoints";function u(e){return"object"!=typeof e||null==e?e:"ref"in e?`$${u(e.ref)}`:"fn"in e?`${e.fn}(${(e.argv||[]).map(u).join(", ")})`:JSON.stringify(e,null,2)}class f extends Error{constructor(e){super(e),this.name="EndpointError"}}const a=(e,r)=>(e=>{const r=e.split("."),t=[];for(const n of r){const r=n.indexOf("[");if(-1!==r){if(n.indexOf("]")!==n.length-1)throw new f(`Path: '${e}' does not end with ']'`);const o=n.slice(r+1,-1);if(Number.isNaN(parseInt(o)))throw new f(`Invalid array index: '${o}' in path: '${e}'`);0!==r&&t.push(n.slice(0,r)),t.push(o)}else t.push(n)}return t})(r).reduce((t,n)=>{if("object"!=typeof t)throw new f(`Index '${n}' in '${r}' not found in '${JSON.stringify(e)}'`);return Array.isArray(t)?t[parseInt(n)]:t[n]},e),l={[e.HTTP]:80,[e.HTTPS]:443},d={booleanEquals:(e,r)=>e===r,getAttr:a,isSet:e=>null!=e,isValidHostLabel:s,not:e=>!e,parseURL:r=>{const t=(()=>{try{if(r instanceof URL)return r;if("object"==typeof r&&"hostname"in r){const{hostname:e,port:t,protocol:n="",path:o="",query:s={}}=r,i=new URL(`${n}//${e}${t?`:${t}`:""}${o}`);return i.search=Object.entries(s).map(([e,r])=>`${e}=${r}`).join("&"),i}return new URL(r)}catch(e){return null}})();if(!t)return null;const o=t.href,{host:s,hostname:i,pathname:c,protocol:u,search:f}=t;if(f)return null;const a=u.slice(0,-1);if(!Object.values(e).includes(a))return null;const d=n(i);return{scheme:a,authority:`${s}${o.includes(`${s}:${l[a]}`)||"string"==typeof r&&r.includes(`${s}:${l[a]}`)?`:${l[a]}`:""}`,path:c,normalizedPath:c.endsWith("/")?c:`${c}/`,isIp:d}},stringEquals:(e,r)=>e===r,substring:(e,r,t,n)=>r>=t||e.length<t?null:n?e.substring(e.length-t,e.length-r):e.substring(r,t),uriEncode:e=>encodeURIComponent(e).replace(/[!*'()]/g,e=>`%${e.charCodeAt(0).toString(16).toUpperCase()}`)},p=(e,r)=>{const t=[],n={...r.endpointParams,...r.referenceRecord};let o=0;for(;o<e.length;){const r=e.indexOf("{",o);if(-1===r){t.push(e.slice(o));break}t.push(e.slice(o,r));const s=e.indexOf("}",r);if(-1===s){t.push(e.slice(r));break}"{"===e[r+1]&&"}"===e[s+1]&&(t.push(e.slice(r+1,s)),o=s+2);const i=e.substring(r+1,s);if(i.includes("#")){const[e,r]=i.split("#");t.push(a(n[e],r))}else t.push(n[i]);o=s+1}return t.join("")},h=(e,r,t)=>{if("string"==typeof e)return p(e,t);if(e.fn)return $(e,t);if(e.ref)return(({ref:e},r)=>({...r.endpointParams,...r.referenceRecord}[e]))(e,t);throw new f(`'${r}': ${String(e)} is not a string, function or reference.`)},$=({fn:e,argv:r},t)=>{const n=r.map(e=>["boolean","number"].includes(typeof e)?e:h(e,"arg",t)),o=e.split(".");return o[0]in i&&null!=o[1]?i[o[0]][o[1]](...n):d[e](...n)},w=({assign:e,...r},t)=>{if(e&&e in t.referenceRecord)throw new f(`'${e}' is already defined in Reference Record.`);const n=$(r,t);return t.logger?.debug?.(`${c} evaluateCondition: ${u(r)} = ${u(n)}`),{result:""===n||!!n,...null!=e&&{toAssign:{name:e,value:n}}}},g=(e=[],r)=>{const t={};for(const n of e){const{result:e,toAssign:o}=w(n,{...r,referenceRecord:{...r.referenceRecord,...t}});if(!e)return{result:e};o&&(t[o.name]=o.value,r.logger?.debug?.(`${c} assign: ${o.name} := ${u(o.value)}`))}return{result:!0,referenceRecord:t}},y=(e,r)=>Object.entries(e).reduce((e,[t,n])=>({...e,[t]:n.map(e=>{const n=h(e,"Header value entry",r);if("string"!=typeof n)throw new f(`Header '${t}' value '${n}' is not a string`);return n})}),{}),R=(e,r)=>{if(Array.isArray(e))return e.map(e=>R(e,r));switch(typeof e){case"string":return p(e,r);case"object":if(null===e)throw new f(`Unexpected endpoint property: ${e}`);return m(e,r);case"boolean":return e;default:throw new f("Unexpected endpoint property type: "+typeof e)}},m=(e,r)=>Object.entries(e).reduce((e,[t,n])=>({...e,[t]:R(n,r)}),{}),b=(e,r)=>{const t=h(e,"Endpoint URL",r);if("string"==typeof t)try{return new URL(t)}catch(n){throw n}throw new f("Endpoint URL must be a string, got "+typeof t)},E=(e,r)=>{const{conditions:t,endpoint:n}=e,{result:o,referenceRecord:s}=g(t,r);if(!o)return;const i={...r,referenceRecord:{...r.referenceRecord,...s}},{url:f,properties:a,headers:l}=n;return r.logger?.debug?.(`${c} Resolving endpoint from template: ${u(n)}`),{...null!=l&&{headers:y(l,i)},...null!=a&&{properties:m(a,i)},url:b(f,i)}},j=(e,r)=>{const{conditions:t,error:n}=e,{result:o,referenceRecord:s}=g(t,r);if(o)throw new f(h(n,"Error",{...r,referenceRecord:{...r.referenceRecord,...s}}))},v=(e,r)=>{const{conditions:t,rules:n}=e,{result:o,referenceRecord:s}=g(t,r);if(o)return U(n,{...r,referenceRecord:{...r.referenceRecord,...s}})},U=(e,r)=>{for(const t of e)if("endpoint"===t.type){const e=E(t,r);if(e)return e}else if("error"===t.type)j(t,r);else{if("tree"!==t.type)throw new f(`Unknown endpoint rule: ${t}`);{const e=v(t,r);if(e)return e}}throw new f("Rules evaluation failed")},x=(e,r)=>{const{endpointParams:t,logger:n}=r,{parameters:o,rules:s}=e;r.logger?.debug?.(`${c} Initial EndpointParams: ${u(t)}`);const i=Object.entries(o).filter(([,e])=>null!=e.default).map(([e,r])=>[e,r.default]);if(i.length>0)for(const[c,u]of i)t[c]=t[c]??u;const a=Object.entries(o).filter(([,e])=>e.required).map(([e])=>e);for(const c of a)if(null==t[c])throw new f(`Missing required parameter: '${c}'`);const l=U(s,{endpointParams:t,logger:n,referenceRecord:{}});return r.logger?.debug?.(`${c} Resolved endpoint: ${u(l)}`),l};export{r as E,n as a,i as c,s as i,x as r};
