import{C as e}from"./vendor-aws-crypto-crc32-B1UHIl9t.js";import{t,f as r}from"./vendor-smithy-util-hex-encoding-CCWyKaJD.js";class s{constructor(e){if(this.bytes=e,8!==e.byteLength)throw new Error("Int64 buffers must be exactly 8 bytes")}static fromNumber(e){if(e>0x8000000000000000||e<-0x8000000000000000)throw new Error(`${e} is too large (or, if negative, too small) to represent as an Int64`);const t=new Uint8Array(8);for(let r=7,s=Math.abs(Math.round(e));r>-1&&s>0;r--,s/=256)t[r]=s;return e<0&&n(t),new s(t)}valueOf(){const e=this.bytes.slice(0),r=128&e[0];return r&&n(e),parseInt(t(e),16)*(r?-1:1)}toString(){return String(this.valueOf())}}function n(e){for(let t=0;t<8;t++)e[t]^=255;for(let t=7;t>-1&&(e[t]++,0===e[t]);t--);}class a{constructor(e,t){this.toUtf8=e,this.fromUtf8=t}format(e){const t=[];for(const n of Object.keys(e)){const r=this.fromUtf8(n);t.push(Uint8Array.from([r.byteLength]),r,this.formatHeaderValue(e[n]))}const r=new Uint8Array(t.reduce((e,t)=>e+t.byteLength,0));let s=0;for(const n of t)r.set(n,s),s+=n.byteLength;return r}formatHeaderValue(e){switch(e.type){case"boolean":return Uint8Array.from([e.value?0:1]);case"byte":return Uint8Array.from([2,e.value]);case"short":const t=new DataView(new ArrayBuffer(3));return t.setUint8(0,3),t.setInt16(1,e.value,!1),new Uint8Array(t.buffer);case"integer":const n=new DataView(new ArrayBuffer(5));return n.setUint8(0,4),n.setInt32(1,e.value,!1),new Uint8Array(n.buffer);case"long":const a=new Uint8Array(9);return a[0]=5,a.set(e.value.bytes,1),a;case"binary":const o=new DataView(new ArrayBuffer(3+e.value.byteLength));o.setUint8(0,6),o.setUint16(1,e.value.byteLength,!1);const i=new Uint8Array(o.buffer);return i.set(e.value,3),i;case"string":const c=this.fromUtf8(e.value),h=new DataView(new ArrayBuffer(3+c.byteLength));h.setUint8(0,7),h.setUint16(1,c.byteLength,!1);const y=new Uint8Array(h.buffer);return y.set(c,3),y;case"timestamp":const w=new Uint8Array(9);return w[0]=8,w.set(s.fromNumber(e.value.valueOf()).bytes,1),w;case"uuid":if(!b.test(e.value))throw new Error(`Invalid UUID received: ${e.value}`);const u=new Uint8Array(17);return u[0]=9,u.set(r(e.value.replace(/\-/g,"")),1),u}}parse(e){const r={};let n=0;for(;n<e.byteLength;){const a=e.getUint8(n++),o=this.toUtf8(new Uint8Array(e.buffer,e.byteOffset+n,a));switch(n+=a,e.getUint8(n++)){case 0:r[o]={type:c,value:!0};break;case 1:r[o]={type:c,value:!1};break;case 2:r[o]={type:h,value:e.getInt8(n++)};break;case 3:r[o]={type:y,value:e.getInt16(n,!1)},n+=2;break;case 4:r[o]={type:w,value:e.getInt32(n,!1)},n+=4;break;case 5:r[o]={type:u,value:new s(new Uint8Array(e.buffer,e.byteOffset+n,8))},n+=8;break;case 6:const a=e.getUint16(n,!1);n+=2,r[o]={type:f,value:new Uint8Array(e.buffer,e.byteOffset+n,a)},n+=a;break;case 7:const i=e.getUint16(n,!1);n+=2,r[o]={type:l,value:this.toUtf8(new Uint8Array(e.buffer,e.byteOffset+n,i))},n+=i;break;case 8:r[o]={type:d,value:new Date(new s(new Uint8Array(e.buffer,e.byteOffset+n,8)).valueOf())},n+=8;break;case 9:const b=new Uint8Array(e.buffer,e.byteOffset+n,16);n+=16,r[o]={type:m,value:`${t(b.subarray(0,4))}-${t(b.subarray(4,6))}-${t(b.subarray(6,8))}-${t(b.subarray(8,10))}-${t(b.subarray(10))}`};break;default:throw new Error("Unrecognized header type tag")}}return r}}var o,i;(i=o||(o={}))[i.boolTrue=0]="boolTrue",i[i.boolFalse=1]="boolFalse",i[i.byte=2]="byte",i[i.short=3]="short",i[i.integer=4]="integer",i[i.long=5]="long",i[i.byteArray=6]="byteArray",i[i.string=7]="string",i[i.timestamp=8]="timestamp",i[i.uuid=9]="uuid";const c="boolean",h="byte",y="short",w="integer",u="long",f="binary",l="string",d="timestamp",m="uuid",b=/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;class g{constructor(e,t){this.headerMarshaller=new a(e,t),this.messageBuffer=[],this.isEndOfStream=!1}feed(e){this.messageBuffer.push(this.decode(e))}endOfStream(){this.isEndOfStream=!0}getMessage(){const e=this.messageBuffer.pop(),t=this.isEndOfStream;return{getMessage:()=>e,isEndOfStream:()=>t}}getAvailableMessages(){const e=this.messageBuffer;this.messageBuffer=[];const t=this.isEndOfStream;return{getMessages:()=>e,isEndOfStream:()=>t}}encode({headers:t,body:r}){const s=this.headerMarshaller.format(t),n=s.byteLength+r.byteLength+16,a=new Uint8Array(n),o=new DataView(a.buffer,a.byteOffset,a.byteLength),i=new e;return o.setUint32(0,n,!1),o.setUint32(4,s.byteLength,!1),o.setUint32(8,i.update(a.subarray(0,8)).digest(),!1),a.set(s,12),a.set(r,s.byteLength+12),o.setUint32(n-4,i.update(a.subarray(8,n-4)).digest(),!1),a}decode(t){const{headers:r,body:s}=function({byteLength:t,byteOffset:r,buffer:s}){if(t<16)throw new Error("Provided message too short to accommodate event stream message overhead");const n=new DataView(s,r,t),a=n.getUint32(0,!1);if(t!==a)throw new Error("Reported message length does not match received message length");const o=n.getUint32(4,!1),i=n.getUint32(8,!1),c=n.getUint32(t-4,!1),h=(new e).update(new Uint8Array(s,r,8));if(i!==h.digest())throw new Error(`The prelude checksum specified in the message (${i}) does not match the calculated CRC32 checksum (${h.digest()})`);if(h.update(new Uint8Array(s,r+8,t-12)),c!==h.digest())throw new Error(`The message checksum (${h.digest()}) did not match the expected value of ${c}`);return{headers:new DataView(s,r+8+4,o),body:new Uint8Array(s,r+8+4+o,a-o-16)}}(t);return{headers:this.headerMarshaller.parse(r),body:s}}formatHeaders(e){return this.headerMarshaller.format(e)}}class A{constructor(e){this.options=e}[Symbol.asyncIterator](){return this.asyncIterator()}async*asyncIterator(){for await(const e of this.options.inputStream){const t=this.options.decoder.decode(e);yield t}}}class U{constructor(e){this.options=e}[Symbol.asyncIterator](){return this.asyncIterator()}async*asyncIterator(){for await(const e of this.options.messageStream){const t=this.options.encoder.encode(e);yield t}this.options.includeEndFrame&&(yield new Uint8Array(0))}}class p{constructor(e){this.options=e}[Symbol.asyncIterator](){return this.asyncIterator()}async*asyncIterator(){for await(const e of this.options.messageStream){const t=await this.options.deserializer(e);void 0!==t&&(yield t)}}}class v{constructor(e){this.options=e}[Symbol.asyncIterator](){return this.asyncIterator()}async*asyncIterator(){for await(const e of this.options.inputStream){const t=this.options.serializer(e);yield t}}}export{g as E,A as M,p as S,U as a,v as b};
