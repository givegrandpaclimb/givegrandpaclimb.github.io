import{t as e,f as t}from"./vendor-smithy-util-hex-encoding-DhdgocZN.js";import{a as s,f as r}from"./vendor-smithy-util-utf8-MtSxxKG8.js";import{i as n}from"./vendor-smithy-is-array-buffer-DPIx95ez.js";import{a}from"./vendor-smithy-protocol-http-D-24QeOr.js";import{e as i}from"./vendor-smithy-util-uri-escape-CT7eTZv_.js";import{n as o}from"./vendor-smithy-util-middleware-I6Z6a_gz.js";const c="X-Amz-Date",g="X-Amz-Signature",h="X-Amz-Security-Token",u="authorization",l=c.toLowerCase(),d=[u,l,"date"],f=g.toLowerCase(),y="x-amz-content-sha256",w=h.toLowerCase(),m={authorization:!0,"cache-control":!0,connection:!0,expect:!0,from:!0,"keep-alive":!0,"max-forwards":!0,pragma:!0,referer:!0,te:!0,trailer:!0,"transfer-encoding":!0,upgrade:!0,"user-agent":!0,"x-amzn-trace-id":!0},p=/^proxy-/,b=/^sec-/,v="AWS4-HMAC-SHA256",A="AWS4-HMAC-SHA256-PAYLOAD",S="aws4_request",$={},D=[],C=(e,t,s)=>`${e}/${t}/${s}/${S}`,j=(e,t,r)=>{const n=new e(t);return n.update(s(r)),n.digest()},L=({headers:e},t,s)=>{const r={};for(const n of Object.keys(e).sort()){if(null==e[n])continue;const a=n.toLowerCase();(a in m||t?.has(a)||p.test(a)||b.test(a))&&(!s||s&&!s.has(a))||(r[a]=e[n].trim().replace(/\s+/g," "))}return r},k=async({headers:t,body:r},a)=>{for(const e of Object.keys(t))if(e.toLowerCase()===y)return t[e];if(null==r)return"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";if("string"==typeof r||ArrayBuffer.isView(r)||n(r)){const t=new a;return t.update(s(r)),e(await t.digest())}return"UNSIGNED-PAYLOAD"};class U{format(e){const t=[];for(const a of Object.keys(e)){const s=r(a);t.push(Uint8Array.from([s.byteLength]),s,this.formatHeaderValue(e[a]))}const s=new Uint8Array(t.reduce((e,t)=>e+t.byteLength,0));let n=0;for(const r of t)s.set(r,n),n+=r.byteLength;return s}formatHeaderValue(e){switch(e.type){case"boolean":return Uint8Array.from([e.value?0:1]);case"byte":return Uint8Array.from([2,e.value]);case"short":const s=new DataView(new ArrayBuffer(3));return s.setUint8(0,3),s.setInt16(1,e.value,!1),new Uint8Array(s.buffer);case"integer":const n=new DataView(new ArrayBuffer(5));return n.setUint8(0,4),n.setInt32(1,e.value,!1),new Uint8Array(n.buffer);case"long":const a=new Uint8Array(9);return a[0]=5,a.set(e.value.bytes,1),a;case"binary":const i=new DataView(new ArrayBuffer(3+e.value.byteLength));i.setUint8(0,6),i.setUint16(1,e.value.byteLength,!1);const o=new Uint8Array(i.buffer);return o.set(e.value,3),o;case"string":const c=r(e.value),g=new DataView(new ArrayBuffer(3+c.byteLength));g.setUint8(0,7),g.setUint16(1,c.byteLength,!1);const h=new Uint8Array(g.buffer);return h.set(c,3),h;case"timestamp":const u=new Uint8Array(9);return u[0]=8,u.set(q.fromNumber(e.value.valueOf()).bytes,1),u;case"uuid":if(!R.test(e.value))throw new Error(`Invalid UUID received: ${e.value}`);const l=new Uint8Array(17);return l[0]=9,l.set(t(e.value.replace(/\-/g,"")),1),l}}}var H,P;(P=H||(H={}))[P.boolTrue=0]="boolTrue",P[P.boolFalse=1]="boolFalse",P[P.byte=2]="byte",P[P.short=3]="short",P[P.integer=4]="integer",P[P.long=5]="long",P[P.byteArray=6]="byteArray",P[P.string=7]="string",P[P.timestamp=8]="timestamp",P[P.uuid=9]="uuid";const R=/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;class q{constructor(e){if(this.bytes=e,8!==e.byteLength)throw new Error("Int64 buffers must be exactly 8 bytes")}static fromNumber(e){if(e>0x8000000000000000||e<-0x8000000000000000)throw new Error(`${e} is too large (or, if negative, too small) to represent as an Int64`);const t=new Uint8Array(8);for(let s=7,r=Math.abs(Math.round(e));s>-1&&r>0;s--,r/=256)t[s]=r;return e<0&&x(t),new q(t)}valueOf(){const t=this.bytes.slice(0),s=128&t[0];return s&&x(t),parseInt(e(t),16)*(s?-1:1)}toString(){return String(this.valueOf())}}function x(e){for(let t=0;t<8;t++)e[t]^=255;for(let t=7;t>-1&&(e[t]++,0===e[t]);t--);}const O=e=>{e=a.clone(e);for(const t of Object.keys(e.headers))d.indexOf(t.toLowerCase())>-1&&delete e.headers[t];return e};class E{constructor({applyChecksum:e,credentials:t,region:s,service:r,sha256:n,uriEscapePath:a=!0}){this.service=r,this.sha256=n,this.uriEscapePath=a,this.applyChecksum="boolean"!=typeof e||e,this.regionProvider=o(s),this.credentialProvider=o(t)}createCanonicalRequest(e,t,s){const r=Object.keys(t).sort();return`${e.method}\n${this.getCanonicalPath(e)}\n${(({query:e={}})=>{const t=[],s={};for(const r of Object.keys(e)){if(r.toLowerCase()===f)continue;const n=i(r);t.push(n);const a=e[r];"string"==typeof a?s[n]=`${n}=${i(a)}`:Array.isArray(a)&&(s[n]=a.slice(0).reduce((e,t)=>e.concat([`${n}=${i(t)}`]),[]).sort().join("&"))}return t.sort().map(e=>s[e]).filter(e=>e).join("&")})(e)}\n${r.map(e=>`${e}:${t[e]}`).join("\n")}\n\n${r.join(";")}\n${s}`}async createStringToSign(t,r,n,a){const i=new this.sha256;i.update(s(n));const o=await i.digest();return`${a}\n${t}\n${r}\n${e(o)}`}getCanonicalPath({path:e}){if(this.uriEscapePath){const t=[];for(const r of e.split("/"))0!==r?.length&&"."!==r&&(".."===r?t.pop():t.push(r));const s=`${e?.startsWith("/")?"/":""}${t.join("/")}${t.length>0&&e?.endsWith("/")?"/":""}`;return i(s).replace(/%2F/g,"/")}return e}validateResolvedCredentials(e){if("object"!=typeof e||"string"!=typeof e.accessKeyId||"string"!=typeof e.secretAccessKey)throw new Error("Resolved credential object is not valid")}formatDate(e){const t=(s=e,(e=>"number"==typeof e?new Date(1e3*e):"string"==typeof e?Number(e)?new Date(1e3*Number(e)):new Date(e):e)(s).toISOString().replace(/\.\d{3}Z$/,"Z")).replace(/[\-:]/g,"");var s;return{longDate:t,shortDate:t.slice(0,8)}}getCanonicalHeaderList(e){return Object.keys(e).sort().join(";")}}class I extends E{constructor({applyChecksum:e,credentials:t,region:s,service:r,sha256:n,uriEscapePath:a=!0}){super({applyChecksum:e,credentials:t,region:s,service:r,sha256:n,uriEscapePath:a}),this.headerFormatter=new U}async presign(e,t={}){const{signingDate:s=new Date,expiresIn:r=3600,unsignableHeaders:n,unhoistableHeaders:i,signableHeaders:o,hoistableHeaders:u,signingRegion:l,signingService:d}=t,f=await this.credentialProvider();this.validateResolvedCredentials(f);const y=l??await this.regionProvider(),{longDate:w,shortDate:m}=this.formatDate(s);if(r>604800)return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");const p=C(m,y,d??this.service),b=((e,t={})=>{const{headers:s,query:r={}}=a.clone(e);for(const n of Object.keys(s)){const e=n.toLowerCase();("x-amz-"===e.slice(0,6)&&!t.unhoistableHeaders?.has(e)||t.hoistableHeaders?.has(e))&&(r[n]=s[n],delete s[n])}return{...e,headers:s,query:r}})(O(e),{unhoistableHeaders:i,hoistableHeaders:u});f.sessionToken&&(b.query[h]=f.sessionToken),b.query["X-Amz-Algorithm"]=v,b.query["X-Amz-Credential"]=`${f.accessKeyId}/${p}`,b.query[c]=w,b.query["X-Amz-Expires"]=r.toString(10);const A=L(b,n,o);return b.query["X-Amz-SignedHeaders"]=this.getCanonicalHeaderList(A),b.query[g]=await this.getSignature(w,p,this.getSigningKey(f,y,m,d),this.createCanonicalRequest(b,A,await k(e,this.sha256))),b}async sign(e,t){return"string"==typeof e?this.signString(e,t):e.headers&&e.payload?this.signEvent(e,t):e.message?this.signMessage(e,t):this.signRequest(e,t)}async signEvent({headers:t,payload:s},{signingDate:r=new Date,priorSignature:n,signingRegion:a,signingService:i}){const o=a??await this.regionProvider(),{shortDate:c,longDate:g}=this.formatDate(r),h=C(c,o,i??this.service),u=await k({headers:{},body:s},this.sha256),l=new this.sha256;l.update(t);const d=e(await l.digest()),f=[A,g,h,n,d,u].join("\n");return this.signString(f,{signingDate:r,signingRegion:o,signingService:i})}async signMessage(e,{signingDate:t=new Date,signingRegion:s,signingService:r}){return this.signEvent({headers:this.headerFormatter.format(e.message.headers),payload:e.message.body},{signingDate:t,signingRegion:s,signingService:r,priorSignature:e.priorSignature}).then(t=>({message:e.message,signature:t}))}async signString(t,{signingDate:r=new Date,signingRegion:n,signingService:a}={}){const i=await this.credentialProvider();this.validateResolvedCredentials(i);const o=n??await this.regionProvider(),{shortDate:c}=this.formatDate(r),g=new this.sha256(await this.getSigningKey(i,o,c,a));return g.update(s(t)),e(await g.digest())}async signRequest(e,{signingDate:t=new Date,signableHeaders:s,unsignableHeaders:r,signingRegion:n,signingService:a}={}){const i=await this.credentialProvider();this.validateResolvedCredentials(i);const o=n??await this.regionProvider(),c=O(e),{longDate:g,shortDate:h}=this.formatDate(t),d=C(h,o,a??this.service);c.headers[l]=g,i.sessionToken&&(c.headers[w]=i.sessionToken);const f=await k(c,this.sha256);!((e,t)=>{e=e.toLowerCase();for(const s of Object.keys(t))if(e===s.toLowerCase())return!0;return!1})(y,c.headers)&&this.applyChecksum&&(c.headers[y]=f);const m=L(c,r,s),p=await this.getSignature(g,d,this.getSigningKey(i,o,h,a),this.createCanonicalRequest(c,m,f));return c.headers[u]=`${v} Credential=${i.accessKeyId}/${d}, SignedHeaders=${this.getCanonicalHeaderList(m)}, Signature=${p}`,c}async getSignature(t,r,n,a){const i=await this.createStringToSign(t,r,a,v),o=new this.sha256(await n);return o.update(s(i)),e(await o.digest())}getSigningKey(t,s,r,n){return(async(t,s,r,n,a)=>{const i=await j(t,s.secretAccessKey,s.accessKeyId),o=`${r}:${n}:${a}:${e(i)}:${s.sessionToken}`;if(o in $)return $[o];for(D.push(o);D.length>50;)delete $[D.shift()];let c=`AWS4${s.secretAccessKey}`;for(const e of[r,n,a,S])c=await j(t,c,e);return $[o]=c})(this.sha256,t,r,s,n||this.service)}}export{I as S};
