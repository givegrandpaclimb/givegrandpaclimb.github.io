import{p as e}from"./vendor-lezer-go-DSeKgRAf.js";import{L as t,c as a,d as n,f as o,e as r,h as l,j as i,k as c,s}from"./vendor-codemirror-language-BPIDEO9h.js";import{s as m,i as p,c as d}from"./vendor-codemirror-autocomplete-DSfl44C_.js";import{a as f,I as u}from"./vendor-lezer-common-3JYFuo68.js";import"./vendor-lezer-lr-kLeAvj2c.js";import"./vendor-lezer-highlight-QzoJ8SKk.js";import"./vendor-codemirror-state-d-AKQu11.js";import"./vendor-marijn-find-cluster-break-Dub_CRYN.js";import"./vendor-codemirror-view-BFv1CI2l.js";import"./vendor-style-mod-_NPnILvn.js";import"./vendor-w3c-keyname-f-y9tSbI.js";const y=[m("func ${name}(${params}) ${type} {\n\t${}\n}",{label:"func",detail:"declaration",type:"keyword"}),m("func (${receiver}) ${name}(${params}) ${type} {\n\t${}\n}",{label:"func",detail:"method declaration",type:"keyword"}),m("var ${name} = ${value}",{label:"var",detail:"declaration",type:"keyword"}),m("type ${name} ${type}",{label:"type",detail:"declaration",type:"keyword"}),m("const ${name} = ${value}",{label:"const",detail:"declaration",type:"keyword"}),m("type ${name} = ${type}",{label:"type",detail:"alias declaration",type:"keyword"}),m("for ${init}; ${test}; ${update} {\n\t${}\n}",{label:"for",detail:"loop",type:"keyword"}),m("for ${i} := range ${value} {\n\t${}\n}",{label:"for",detail:"range",type:"keyword"}),m("select {\n\t${}\n}",{label:"select",detail:"statement",type:"keyword"}),m("case ${}:\n${}",{label:"case",type:"keyword"}),m("switch ${} {\n\t${}\n}",{label:"switch",detail:"statement",type:"keyword"}),m("switch ${}.(${type}) {\n\t${}\n}",{label:"switch",detail:"type statement",type:"keyword"}),m("if ${} {\n\t${}\n}",{label:"if",detail:"block",type:"keyword"}),m("if ${} {\n\t${}\n} else {\n\t${}\n}",{label:"if",detail:"/ else block",type:"keyword"}),m('import ${name} "${module}"\n${}',{label:"import",detail:"declaration",type:"keyword"})],$=new f,k=new Set(["SourceFile","Block","FunctionDecl","MethodDecl","FunctionLiteral","ForStatement","SwitchStatement","TypeSwitchStatement","IfStatement"]);function b(e,t){return(a,n)=>{e:for(let o=a.node.firstChild,r=0,l=null;;){for(;!o;){if(!r)break e;r--,o=l.nextSibling,l=l.parent}t&&o.name==t||"SpecList"==o.name?(r++,l=o,o=o.firstChild):("DefName"==o.name&&n(o,e),o=o.nextSibling)}return!0}}const w={FunctionDecl:b("function"),VarDecl:b("var","VarSpec"),ConstDecl:b("constant","ConstSpec"),TypeDecl:b("type","TypeSpec"),ImportDecl:b("constant","ImportSpec"),Parameter:b("var"),__proto__:null};function S(e,t){let a=$.get(t);if(a)return a;let n=[],o=!0;function r(t,a){let o=e.sliceString(t.from,t.to);n.push({label:o,type:a})}return t.cursor(u.IncludeAnonymous).iterate(t=>{if(o)o=!1;else if(t.name){let e=w[t.name];if(e&&e(t,r)||k.has(t.name))return!1}else if(t.to-t.from>8192){for(let a of S(e,t.node))n.push(a);return!1}}),$.set(t,n),n}const h=/^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/,g=["String","LineComment","BlockComment","DefName","LabelName","FieldName",".","?."],v=e=>{let t=s(e.state).resolveInner(e.pos,-1);if(g.indexOf(t.name)>-1)return null;let a="VariableName"==t.name||t.to-t.from<20&&h.test(e.state.sliceDoc(t.from,t.to));if(!a&&!e.explicit)return null;let n=[];for(let o=t;o;o=o.parent)k.has(o.name)&&(n=n.concat(S(e.state.doc,o)));return{options:n,from:a?t.from:e.pos,validFor:h}},j=t.define({name:"go",parser:e.configure({props:[n.add({IfStatement:r({except:/^\s*({|else\b)/}),LabeledStatement:i,"SwitchBlock SelectBlock":e=>{let t=e.textAfter,a=/^\s*\}/.test(t),n=/^\s*(case|default)\b/.test(t);return e.baseIndent+(a||n?0:e.unit)},Block:l({closing:"}"}),BlockComment:()=>null,Statement:r({except:/^{/})}),o.add({"Block SwitchBlock SelectBlock LiteralValue InterfaceType StructType SpecList":c,BlockComment:e=>({from:e.from+2,to:e.to-2})})]}),languageData:{closeBrackets:{brackets:["(","[","{","'",'"',"`"]},commentTokens:{line:"//",block:{open:"/*",close:"*/"}},indentOnInput:/^\s*(?:case\b|default\b|\})$/}});let B=e=>({label:e,type:"keyword"});const D="interface struct chan map package go return break continue goto fallthrough else defer range true false nil".split(" ").map(B);function x(){let e=y.concat(D);return new a(j,[j.data.of({autocomplete:p(g,d(e))}),j.data.of({autocomplete:v})])}export{x as go,j as goLanguage,v as localCompletionSource,y as snippets};
