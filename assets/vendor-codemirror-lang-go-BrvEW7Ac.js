import{p as e}from"./vendor-lezer-go-DJVgAtRB.js";import{L as t,c as a,d as l,f as r,e as o,h as n,j as c,k as i,s}from"./vendor-codemirror-language-C3hkV707.js";import{s as p,i as m,c as d}from"./vendor-codemirror-autocomplete-BSg-hdYo.js";import{a as f,I as u}from"./vendor-lezer-common-QPiu6Hcj.js";import"./vendor-lezer-lr-CZr-wB1l.js";import"./vendor-lezer-highlight-4-fykoed.js";import"./vendor-codemirror-state-D88w-V9V.js";import"./vendor-marijn-find-cluster-break-BFVNO93u.js";import"./vendor-codemirror-view-DVzN21hM.js";import"./vendor-style-mod-tLAqh-pC.js";import"./vendor-w3c-keyname-BorKtCV5.js";const y=[p("func ${name}(${params}) ${type} {\n\t${}\n}",{label:"func",detail:"declaration",type:"keyword"}),p("func (${receiver}) ${name}(${params}) ${type} {\n\t${}\n}",{label:"func",detail:"method declaration",type:"keyword"}),p("var ${name} = ${value}",{label:"var",detail:"declaration",type:"keyword"}),p("type ${name} ${type}",{label:"type",detail:"declaration",type:"keyword"}),p("const ${name} = ${value}",{label:"const",detail:"declaration",type:"keyword"}),p("type ${name} = ${type}",{label:"type",detail:"alias declaration",type:"keyword"}),p("for ${init}; ${test}; ${update} {\n\t${}\n}",{label:"for",detail:"loop",type:"keyword"}),p("for ${i} := range ${value} {\n\t${}\n}",{label:"for",detail:"range",type:"keyword"}),p("select {\n\t${}\n}",{label:"select",detail:"statement",type:"keyword"}),p("case ${}:\n${}",{label:"case",type:"keyword"}),p("switch ${} {\n\t${}\n}",{label:"switch",detail:"statement",type:"keyword"}),p("switch ${}.(${type}) {\n\t${}\n}",{label:"switch",detail:"type statement",type:"keyword"}),p("if ${} {\n\t${}\n}",{label:"if",detail:"block",type:"keyword"}),p("if ${} {\n\t${}\n} else {\n\t${}\n}",{label:"if",detail:"/ else block",type:"keyword"}),p('import ${name} "${module}"\n${}',{label:"import",detail:"declaration",type:"keyword"})],$=new f,k=new Set(["SourceFile","Block","FunctionDecl","MethodDecl","FunctionLiteral","ForStatement","SwitchStatement","TypeSwitchStatement","IfStatement"]);function b(e,t){return(a,l)=>{e:for(let r=a.node.firstChild,o=0,n=null;;){for(;!r;){if(!o)break e;o--,r=n.nextSibling,n=n.parent}t&&r.name==t||"SpecList"==r.name?(o++,n=r,r=r.firstChild):("DefName"==r.name&&l(r,e),r=r.nextSibling)}return!0}}const w={FunctionDecl:b("function"),VarDecl:b("var","VarSpec"),ConstDecl:b("constant","ConstSpec"),TypeDecl:b("type","TypeSpec"),ImportDecl:b("constant","ImportSpec"),Parameter:b("var"),__proto__:null};function S(e,t){let a=$.get(t);if(a)return a;let l=[],r=!0;function o(t,a){let r=e.sliceString(t.from,t.to);l.push({label:r,type:a})}return t.cursor(u.IncludeAnonymous).iterate(t=>{if(r)r=!1;else if(t.name){let e=w[t.name];if(e&&e(t,o)||k.has(t.name))return!1}else if(t.to-t.from>8192){for(let a of S(e,t.node))l.push(a);return!1}}),$.set(t,l),l}const v=/^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/,g=["String","LineComment","BlockComment","DefName","LabelName","FieldName",".","?."],h=e=>{let t=s(e.state).resolveInner(e.pos,-1);if(g.indexOf(t.name)>-1)return null;let a="VariableName"==t.name||t.to-t.from<20&&v.test(e.state.sliceDoc(t.from,t.to));if(!a&&!e.explicit)return null;let l=[];for(let r=t;r;r=r.parent)k.has(r.name)&&(l=l.concat(S(e.state.doc,r)));return{options:l,from:a?t.from:e.pos,validFor:v}},j=t.define({name:"go",parser:e.configure({props:[l.add({IfStatement:o({except:/^\s*({|else\b)/}),LabeledStatement:c,"SwitchBlock SelectBlock":e=>{let t=e.textAfter,a=/^\s*\}/.test(t),l=/^\s*(case|default)\b/.test(t);return e.baseIndent+(a||l?0:e.unit)},Block:n({closing:"}"}),BlockComment:()=>null,Statement:o({except:/^{/})}),r.add({"Block SwitchBlock SelectBlock LiteralValue InterfaceType StructType SpecList":i,BlockComment:e=>({from:e.from+2,to:e.to-2})})]}),languageData:{closeBrackets:{brackets:["(","[","{","'",'"',"`"]},commentTokens:{line:"//",block:{open:"/*",close:"*/"}},indentOnInput:/^\s*(?:case\b|default\b|\})$/}});let B=e=>({label:e,type:"keyword"});const D="interface struct chan map package go return break continue goto fallthrough else defer range true false nil".split(" ").map(B);function L(){let e=y.concat(D);return new a(j,[j.data.of({autocomplete:m(g,d(e))}),j.data.of({autocomplete:h})])}export{L as go,j as goLanguage,h as localCompletionSource,y as snippets};
