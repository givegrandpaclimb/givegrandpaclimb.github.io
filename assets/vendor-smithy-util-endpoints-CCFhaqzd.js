import{E as e}from"./vendor-smithy-types-CI1XBBMP.js";class t{capacity;data=new Map;parameters=[];constructor({size:e,params:t}){this.capacity=e??50,t&&(this.parameters=t)}get(e,t){const r=this.hash(e);if(!1===r)return t();if(!this.data.has(r)){if(this.data.size>this.capacity+10){const e=this.data.keys();let t=0;for(;;){const{value:r,done:n}=e.next();if(this.data.delete(r),n||++t>10)break}}this.data.set(r,t())}return this.data.get(r)}size(){return this.data.size}hash(e){let t="";const{parameters:r}=this;if(0===r.length)return!1;for(const n of r){const r=String(e[n]??"");if(r.includes("|;"))return!1;t+=r+"|;"}return t}}const r=new RegExp("^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$"),n=e=>r.test(e)||e.startsWith("[")&&e.endsWith("]"),s=new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$"),o=(e,t=!1)=>{if(!t)return s.test(e);const r=e.split(".");for(const n of r)if(!o(n))return!1;return!0},i={},a="endpoints";function c(e){return"object"!=typeof e||null==e?e:"ref"in e?`$${c(e.ref)}`:"fn"in e?`${e.fn}(${(e.argv||[]).map(c).join(", ")})`:JSON.stringify(e,null,2)}class u extends Error{constructor(e){super(e),this.name="EndpointError"}}const l=(e,t)=>(e=>{const t=e.split("."),r=[];for(const n of t){const t=n.indexOf("[");if(-1!==t){if(n.indexOf("]")!==n.length-1)throw new u(`Path: '${e}' does not end with ']'`);const s=n.slice(t+1,-1);if(Number.isNaN(parseInt(s)))throw new u(`Invalid array index: '${s}' in path: '${e}'`);0!==t&&r.push(n.slice(0,t)),r.push(s)}else r.push(n)}return r})(t).reduce((r,n)=>{if("object"!=typeof r)throw new u(`Index '${n}' in '${t}' not found in '${JSON.stringify(e)}'`);return Array.isArray(r)?r[parseInt(n)]:r[n]},e),f={[e.HTTP]:80,[e.HTTPS]:443},d={booleanEquals:(e,t)=>e===t,getAttr:l,isSet:e=>null!=e,isValidHostLabel:o,not:e=>!e,parseURL:t=>{const r=(()=>{try{if(t instanceof URL)return t;if("object"==typeof t&&"hostname"in t){const{hostname:e,port:r,protocol:n="",path:s="",query:o={}}=t,i=new URL(`${n}//${e}${r?`:${r}`:""}${s}`);return i.search=Object.entries(o).map(([e,t])=>`${e}=${t}`).join("&"),i}return new URL(t)}catch(e){return null}})();if(!r)return null;const s=r.href,{host:o,hostname:i,pathname:a,protocol:c,search:u}=r;if(u)return null;const l=c.slice(0,-1);if(!Object.values(e).includes(l))return null;const d=n(i);return{scheme:l,authority:`${o}${s.includes(`${o}:${f[l]}`)||"string"==typeof t&&t.includes(`${o}:${f[l]}`)?`:${f[l]}`:""}`,path:a,normalizedPath:a.endsWith("/")?a:`${a}/`,isIp:d}},stringEquals:(e,t)=>e===t,substring:(e,t,r,n)=>t>=r||e.length<r?null:n?e.substring(e.length-r,e.length-t):e.substring(t,r),uriEncode:e=>encodeURIComponent(e).replace(/[!*'()]/g,e=>`%${e.charCodeAt(0).toString(16).toUpperCase()}`)},p=(e,t)=>{const r=[],n={...t.endpointParams,...t.referenceRecord};let s=0;for(;s<e.length;){const t=e.indexOf("{",s);if(-1===t){r.push(e.slice(s));break}r.push(e.slice(s,t));const o=e.indexOf("}",t);if(-1===o){r.push(e.slice(t));break}"{"===e[t+1]&&"}"===e[o+1]&&(r.push(e.slice(t+1,o)),s=o+2);const i=e.substring(t+1,o);if(i.includes("#")){const[e,t]=i.split("#");r.push(l(n[e],t))}else r.push(n[i]);s=o+1}return r.join("")},h=(e,t,r)=>{if("string"==typeof e)return p(e,r);if(e.fn)return $.callFunction(e,r);if(e.ref)return(({ref:e},t)=>({...t.endpointParams,...t.referenceRecord}[e]))(e,r);throw new u(`'${t}': ${String(e)} is not a string, function or reference.`)},g=({fn:e,argv:t},r)=>{const n=t.map(e=>["boolean","number"].includes(typeof e)?e:$.evaluateExpression(e,"arg",r)),s=e.split(".");return s[0]in i&&null!=s[1]?i[s[0]][s[1]](...n):d[e](...n)},$={evaluateExpression:h,callFunction:g},y=({assign:e,...t},r)=>{if(e&&e in r.referenceRecord)throw new u(`'${e}' is already defined in Reference Record.`);const n=g(t,r);return r.logger?.debug?.(`${a} evaluateCondition: ${c(t)} = ${c(n)}`),{result:""===n||!!n,...null!=e&&{toAssign:{name:e,value:n}}}},m=(e=[],t)=>{const r={};for(const n of e){const{result:e,toAssign:s}=y(n,{...t,referenceRecord:{...t.referenceRecord,...r}});if(!e)return{result:e};s&&(r[s.name]=s.value,t.logger?.debug?.(`${a} assign: ${s.name} := ${c(s.value)}`))}return{result:!0,referenceRecord:r}},w=(e,t)=>Object.entries(e).reduce((e,[r,n])=>({...e,[r]:n.map(e=>{const n=h(e,"Header value entry",t);if("string"!=typeof n)throw new u(`Header '${r}' value '${n}' is not a string`);return n})}),{}),R=(e,t)=>Object.entries(e).reduce((e,[r,n])=>({...e,[r]:v.getEndpointProperty(n,t)}),{}),b=(e,t)=>{if(Array.isArray(e))return e.map(e=>b(e,t));switch(typeof e){case"string":return p(e,t);case"object":if(null===e)throw new u(`Unexpected endpoint property: ${e}`);return v.getEndpointProperties(e,t);case"boolean":return e;default:throw new u("Unexpected endpoint property type: "+typeof e)}},v={getEndpointProperty:b,getEndpointProperties:R},E=(e,t)=>{const r=h(e,"Endpoint URL",t);if("string"==typeof r)try{return new URL(r)}catch(n){throw n}throw new u("Endpoint URL must be a string, got "+typeof r)},x=(e,t)=>{const{conditions:r,endpoint:n}=e,{result:s,referenceRecord:o}=m(r,t);if(!s)return;const i={...t,referenceRecord:{...t.referenceRecord,...o}},{url:u,properties:l,headers:f}=n;return t.logger?.debug?.(`${a} Resolving endpoint from template: ${c(n)}`),{...null!=f&&{headers:w(f,i)},...null!=l&&{properties:R(l,i)},url:E(u,i)}},j=(e,t)=>{const{conditions:r,error:n}=e,{result:s,referenceRecord:o}=m(r,t);if(s)throw new u(h(n,"Error",{...t,referenceRecord:{...t.referenceRecord,...o}}))},P=(e,t)=>{for(const r of e)if("endpoint"===r.type){const e=x(r,t);if(e)return e}else if("error"===r.type)j(r,t);else{if("tree"!==r.type)throw new u(`Unknown endpoint rule: ${r}`);{const e=O.evaluateTreeRule(r,t);if(e)return e}}throw new u("Rules evaluation failed")},O={evaluateRules:P,evaluateTreeRule:(e,t)=>{const{conditions:r,rules:n}=e,{result:s,referenceRecord:o}=m(r,t);if(s)return O.evaluateRules(n,{...t,referenceRecord:{...t.referenceRecord,...o}})}},U=(e,t)=>{const{endpointParams:r,logger:n}=t,{parameters:s,rules:o}=e;t.logger?.debug?.(`${a} Initial EndpointParams: ${c(r)}`);const i=Object.entries(s).filter(([,e])=>null!=e.default).map(([e,t])=>[e,t.default]);if(i.length>0)for(const[a,c]of i)r[a]=r[a]??c;const l=Object.entries(s).filter(([,e])=>e.required).map(([e])=>e);for(const a of l)if(null==r[a])throw new u(`Missing required parameter: '${a}'`);const f=P(o,{endpointParams:r,logger:n,referenceRecord:{}});return t.logger?.debug?.(`${a} Resolved endpoint: ${c(f)}`),f};export{t as E,n as a,i as c,o as i,U as r};
