import{f as t,t as e}from"./vendor-smithy-util-base64-Cwpq7CWn.js";import{f as r,t as n}from"./vendor-smithy-util-utf8-xqXQEPn9.js";import{t as s}from"./vendor-smithy-util-hex-encoding-CCWyKaJD.js";import{s as o}from"./vendor-smithy-fetch-http-handler-DGsTRsXx.js";class a extends Uint8Array{static fromString(e,n="utf-8"){if("string"==typeof e)return function(e,n){return"base64"===n?a.mutate(t(e)):a.mutate(r(e))}(e,n);throw new Error(`Unsupported conversion from ${typeof e} to Uint8ArrayBlobAdapter.`)}static mutate(t){return Object.setPrototypeOf(t,a.prototype),t}transformToString(t="utf-8"){return function(t,r="utf-8"){return"base64"===r?e(t):n(t)}(this,t)}}const i="function"==typeof ReadableStream?ReadableStream:function(){};class c extends i{}const f=t=>"function"==typeof ReadableStream&&(t?.constructor?.name===ReadableStream.name||t instanceof ReadableStream),u=({expectedChecksum:t,checksum:r,source:n,checksumSourceLocation:s,base64Encoder:o})=>{if(!f(n))throw new Error(`@smithy/util-stream: unsupported source type ${n?.constructor?.name??n} in ChecksumStream.`);const a=o??e;if("function"!=typeof TransformStream)throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");const i=new TransformStream({start(){},async transform(t,e){r.update(t),e.enqueue(t)},async flush(e){const n=await r.digest(),o=a(n);if(t!==o){const r=new Error(`Checksum mismatch: expected "${t}" but received "${o}" in response header "${s}".`);e.error(r)}else e.terminate()}});n.pipeThrough(i);const u=i.readable;return Object.setPrototypeOf(u,c.prototype),u};class m{constructor(t){this.allocByteArray=t,this.byteLength=0,this.byteArrays=[]}push(t){this.byteArrays.push(t),this.byteLength+=t.byteLength}flush(){if(1===this.byteArrays.length){const t=this.byteArrays[0];return this.reset(),t}const t=this.allocByteArray(this.byteLength);let e=0;for(let r=0;r<this.byteArrays.length;++r){const n=this.byteArrays[r];t.set(n,e),e+=n.byteLength}return this.reset(),t}reset(){this.byteArrays=[],this.byteLength=0}}const l=function(t,e,r){const n=t.getReader();let s=!1,o=0;const a=["",new m(t=>new Uint8Array(t))];let i=-1;const c=async t=>{const{value:f,done:u}=await n.read(),m=f;if(u){if(-1!==i){const e=h(a,i);d(e)>0&&t.enqueue(e)}t.close()}else{const n=function(t,e=!0){return e&&"undefined"!=typeof Buffer&&t instanceof Buffer?2:t instanceof Uint8Array?1:"string"==typeof t?0:-1}(m,!1);if(i!==n&&(i>=0&&t.enqueue(h(a,i)),i=n),-1===i)return void t.enqueue(m);const f=d(m);o+=f;const u=d(a[i]);if(f>=e&&0===u)t.enqueue(m);else{const n=function(t,e,r){switch(e){case 0:return t[0]+=r,d(t[0]);case 1:case 2:return t[e].push(r),d(t[e])}}(a,i,m);!s&&o>2*e&&(s=!0,r?.warn(`@smithy/util-stream - stream chunk size ${f} is below threshold of ${e}, automatically buffering.`)),n>=e?t.enqueue(h(a,i)):await c(t)}}};return new ReadableStream({pull:c})};function h(t,e){switch(e){case 0:const r=t[0];return t[0]="",r;case 1:case 2:return t[e].flush()}throw new Error(`@smithy/util-stream - invalid index ${e} given to flush()`)}function d(t){return t?.byteLength??t?.length??0}const y=(t,e)=>{const{base64Encoder:r,bodyLengthChecker:n,checksumAlgorithmFn:s,checksumLocationName:o,streamHasher:a}=e,i=void 0!==r&&void 0!==n&&void 0!==s&&void 0!==o&&void 0!==a,c=i?a(s,t):void 0,f=t.getReader();return new ReadableStream({async pull(t){const{value:e,done:s}=await f.read();if(s){if(t.enqueue("0\r\n"),i){const e=r(await c);t.enqueue(`${o}:${e}\r\n`),t.enqueue("\r\n")}t.close()}else t.enqueue(`${(n(e)||0).toString(16)}\r\n${e}\r\n`)}})};async function p(t,e){let r=0;const n=[],s=t.getReader();let o=!1;for(;!o;){const{done:t,value:a}=await s.read();if(a&&(n.push(a),r+=a?.byteLength??0),r>=e)break;o=t}s.releaseLock();const a=new Uint8Array(Math.min(e,r));let i=0;for(const c of n){if(c.byteLength>a.byteLength-i){a.set(c.subarray(0,a.byteLength-i),i);break}a.set(c,i),i+=c.length}return a}const w="The stream has already been transformed.",b=t=>{if(!v(t)&&!f(t))throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${t?.__proto__?.constructor?.name||t}`);let r=!1;const a=async()=>{if(r)throw new Error(w);return r=!0,await o(t)};return Object.assign(t,{transformToByteArray:a,transformToString:async t=>{const r=await a();if("base64"===t)return e(r);if("hex"===t)return s(r);if(void 0===t||"utf8"===t||"utf-8"===t)return n(r);if("function"==typeof TextDecoder)return new TextDecoder(t).decode(r);throw new Error("TextDecoder is not available, please make sure polyfill is provided.")},transformToWebStream:()=>{if(r)throw new Error(w);if(r=!0,v(t))return(t=>{if("function"!=typeof t.stream)throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\nIf you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");return t.stream()})(t);if(f(t))return t;throw new Error(`Cannot transform payload to web stream, got ${t}`)}})},v=t=>"function"==typeof Blob&&t instanceof Blob;async function S(t){return"function"==typeof t.stream&&(t=t.stream()),t.tee()}export{a as U,u as a,S as b,l as c,y as g,p as h,b as s};
