import{H as n,a as e}from"./vendor-smithy-protocol-http-BM_qqgGS.js";import{n as t,m as i,k as s,l as r,f as a}from"./vendor-smithy-core-CFTV9i4d.js";import{S as o}from"./vendor-smithy-signature-v4-BP1tcyJ9.js";import{X as c}from"./vendor-fast-xml-parser-CWwNlyG4.js";import{t as g}from"./vendor-smithy-util-utf8-xqXQEPn9.js";import{e as u}from"./vendor-smithy-smithy-client-CncVFqAY.js";function f(n,e,t){n.t?n.t.features||(n.t.features={}):n.t={features:{}},n.t.features[e]=t}const l=e=>n.isInstance(e)?e.headers?.date??e.headers?.Date:void 0,d=n=>new Date(Date.now()+n),m=(n,e)=>{const t=Date.parse(n);return((n,e)=>Math.abs(d(e).getTime()-n)>=3e5)(t,e)?t-Date.now():e},p=(n,e)=>{if(!e)throw new Error(`Property \`${n}\` is not resolved for AWS SDK SigV4Auth`);return e},w=async n=>{const e=p("context",n.context),t=p("config",n.config),i=e.endpointV2?.properties?.authSchemes?.[0],s=p("signer",t.signer),r=await s(i),a=n?.signingRegion,o=n?.signingRegionSet,c=n?.signingName;return{config:t,signer:r,signingRegion:a,signingRegionSet:o,signingName:c}};class v{async sign(n,t,i){if(!e.isInstance(n))throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");const s=await w(i),{config:r,signer:a}=s;let{signingRegion:o,signingName:c}=s;const g=i.context;if(g?.authSchemes?.length){const[n,e]=g.authSchemes;"sigv4a"===n?.name&&"sigv4"===e?.name&&(o=e?.signingRegion??o,c=e?.signingName??c)}return await a.sign(n,{signingDate:d(r.systemClockOffset),signingRegion:o,signingService:c})}errorHandler(n){return e=>{const t=e.ServerTime??l(e.$response);if(t){const i=p("config",n.config),s=i.systemClockOffset;i.systemClockOffset=m(t,i.systemClockOffset),i.systemClockOffset!==s&&e.$metadata&&(e.$metadata.clockSkewCorrected=!0)}throw e}}successHandler(n,e){const t=l(n);if(t){const n=p("config",e.config);n.systemClockOffset=m(t,n.systemClockOffset)}}}class h extends v{async sign(n,t,i){if(!e.isInstance(n))throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");const{config:s,signer:r,signingRegion:a,signingRegionSet:o,signingName:c}=await w(i),g=(await(s.sigv4aSigningRegionSet?.())??o??[a]).join(",");return await r.sign(n,{signingDate:d(s.systemClockOffset),signingRegion:g,signingService:c})}}const y=n=>(n.sigv4aSigningRegionSet=t(n.sigv4aSigningRegionSet),n),b=n=>{let e,a=n.credentials,c=!!n.credentials;Object.defineProperty(n,"credentials",{set(o){o&&o!==a&&o!==e&&(c=!0),a=o;const g=function(n,{credentials:e,credentialDefaultProvider:a}){let o;return o=e?e?.memoized?e:i(e,r,s):a?t(a(Object.assign({},n,{parentClientConfig:n}))):async()=>{throw new Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.")},o.memoized=!0,o}(n,{credentials:a,credentialDefaultProvider:n.credentialDefaultProvider}),u=function(n,e){if(e.configBound)return e;const t=async t=>e({...t,callerClientConfig:n});return t.memoized=e.memoized,t.configBound=!0,t}(n,g);c&&!u.attributed?(e=async n=>u(n).then(n=>function(n){return n.$source||(n.$source={}),n.$source.CREDENTIALS_CODE="e",n}(n)),e.memoized=u.memoized,e.configBound=u.configBound,e.attributed=!0):e=u},get:()=>e,enumerable:!0,configurable:!0}),n.credentials=a;const{signingEscapePath:g=!0,systemClockOffset:u=n.systemClockOffset||0,sha256:f}=n;let l;return l=n.signer?t(n.signer):n.regionInfoProvider?()=>t(n.region)().then(async e=>[await n.regionInfoProvider(e,{useFipsEndpoint:await n.useFipsEndpoint(),useDualstackEndpoint:await n.useDualstackEndpoint()})||{},e]).then(([e,t])=>{const{signingRegion:i,signingService:s}=e;n.signingRegion=n.signingRegion||i||t,n.signingName=n.signingName||s||n.serviceId;const r={...n,credentials:n.credentials,region:n.signingRegion,service:n.signingName,sha256:f,uriEscapePath:g};return new(n.signerConstructor||o)(r)}):async e=>{const i=(e=Object.assign({},{name:"sigv4",signingName:n.signingName||n.defaultSigningName,signingRegion:await t(n.region)(),properties:{}},e)).signingRegion,s=e.signingName;n.signingRegion=n.signingRegion||i,n.signingName=n.signingName||s||n.serviceId;const r={...n,credentials:n.credentials,region:n.signingRegion,service:n.signingName,sha256:f,uriEscapePath:g};return new(n.signerConstructor||o)(r)},Object.assign(n,{systemClockOffset:u,signingEscapePath:g,signer:l})},j=(n,e)=>((n,e)=>a(n,e).then(n=>(e?.utf8Encoder??g)(n)))(n,e).then(n=>{if(n.length){const t=new c({attributeNamePrefix:"",htmlEntities:!0,ignoreAttributes:!1,ignoreDeclaration:!0,parseTagValue:!1,trimValues:!1,tagValueProcessor:(n,e)=>""===e.trim()&&e.includes("\n")?"":void 0});let i;t.addEntity("#xD","\r"),t.addEntity("#10","\n");try{i=t.parse(n,!0)}catch(e){throw e&&"object"==typeof e&&Object.defineProperty(e,"$responseBodyText",{value:n}),e}const s="#text",r=Object.keys(i)[0],a=i[r];return a[s]&&(a[r]=a[s],delete a[s]),u(a)}return{}}),D=async(n,e)=>{const t=await j(n,e);return t.Error&&(t.Error.message=t.Error.message??t.Error.Message),t},E=(n,e)=>void 0!==e?.Error?.Code?e.Error.Code:void 0!==e?.Code?e.Code:404==n.statusCode?"NotFound":void 0;export{v as A,y as a,D as b,h as c,E as l,j as p,b as r,f as s};
