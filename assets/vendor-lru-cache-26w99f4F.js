const t="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,i=new Set,s="object"==typeof process&&process?process:{},e=(t,i,e,h)=>{"function"==typeof s.emitWarning&&s.emitWarning(t,i,e,h)};let h=globalThis.AbortController,o=globalThis.AbortSignal;if(void 0===h){o=class{onabort;t=[];reason;aborted=!1;addEventListener(t,i){this.t.push(i)}},h=class{constructor(){i()}signal=new o;abort(t){if(!this.signal.aborted){this.signal.reason=t,this.signal.aborted=!0;for(const i of this.signal.t)i(t);this.signal.onabort?.(t)}}};let t="1"!==s.env?.LRU_CACHE_IGNORE_AC_WARNING;const i=()=>{t&&(t=!1,e("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",i))}}const n=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),r=t=>n(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?a:null:null;class a extends Array{constructor(t){super(t),this.fill(0)}}class c{heap;length;static#t=!1;static create(t){const i=r(t);if(!i)return[];c.#t=!0;const s=new c(t,i);return c.#t=!1,s}constructor(t,i){if(!c.#t)throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new i(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}}class l{#i;#s;#e;#h;#o;#n;#r;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#a;#c;#l;#f;#u;#d;#p;#v;#w;#m;#g;#y;#S;#b;#T;#A;#z;#x;static unsafeExposeInternals(t){return{starts:t.#S,ttls:t.#b,sizes:t.#y,keyMap:t.#l,keyList:t.#f,valList:t.#u,next:t.#d,prev:t.#p,get head(){return t.#v},get tail(){return t.#w},free:t.#m,isBackgroundFetch:i=>t.#O(i),backgroundFetch:(i,s,e,h)=>t.#E(i,s,e,h),moveToTail:i=>t.#F(i),indexes:i=>t.#C(i),rindexes:i=>t.#D(i),isStale:i=>t.#L(i)}}get max(){return this.#i}get maxSize(){return this.#s}get calculatedSize(){return this.#c}get size(){return this.#a}get fetchMethod(){return this.#n}get memoMethod(){return this.#r}get dispose(){return this.#e}get onInsert(){return this.#h}get disposeAfter(){return this.#o}constructor(t){const{max:s=0,ttl:h,ttlResolution:o=1,ttlAutopurge:a,updateAgeOnGet:f,updateAgeOnHas:u,allowStale:d,dispose:p,onInsert:v,disposeAfter:w,noDisposeOnSet:m,noUpdateTTL:g,maxSize:y=0,maxEntrySize:S=0,sizeCalculation:b,fetchMethod:T,memoMethod:A,noDeleteOnFetchRejection:z,noDeleteOnStaleGet:x,allowStaleOnFetchRejection:O,allowStaleOnFetchAbort:E,ignoreFetchAbort:F}=t;if(0!==s&&!n(s))throw new TypeError("max option must be a nonnegative integer");const C=s?r(s):Array;if(!C)throw new Error("invalid max value: "+s);if(this.#i=s,this.#s=y,this.maxEntrySize=S||this.#s,this.sizeCalculation=b,this.sizeCalculation){if(!this.#s&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw new TypeError("sizeCalculation set to non-function")}if(void 0!==A&&"function"!=typeof A)throw new TypeError("memoMethod must be a function if defined");if(this.#r=A,void 0!==T&&"function"!=typeof T)throw new TypeError("fetchMethod must be a function if specified");if(this.#n=T,this.#A=!!T,this.#l=new Map,this.#f=new Array(s).fill(void 0),this.#u=new Array(s).fill(void 0),this.#d=new C(s),this.#p=new C(s),this.#v=0,this.#w=0,this.#m=c.create(s),this.#a=0,this.#c=0,"function"==typeof p&&(this.#e=p),"function"==typeof v&&(this.#h=v),"function"==typeof w?(this.#o=w,this.#g=[]):(this.#o=void 0,this.#g=void 0),this.#T=!!this.#e,this.#x=!!this.#h,this.#z=!!this.#o,this.noDisposeOnSet=!!m,this.noUpdateTTL=!!g,this.noDeleteOnFetchRejection=!!z,this.allowStaleOnFetchRejection=!!O,this.allowStaleOnFetchAbort=!!E,this.ignoreFetchAbort=!!F,0!==this.maxEntrySize){if(0!==this.#s&&!n(this.#s))throw new TypeError("maxSize must be a positive integer if specified");if(!n(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.#R()}if(this.allowStale=!!d,this.noDeleteOnStaleGet=!!x,this.updateAgeOnGet=!!f,this.updateAgeOnHas=!!u,this.ttlResolution=n(o)||0===o?o:1,this.ttlAutopurge=!!a,this.ttl=h||0,this.ttl){if(!n(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.#_()}if(0===this.#i&&0===this.ttl&&0===this.#s)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#i&&!this.#s){const t="LRU_CACHE_UNBOUNDED";(t=>!i.has(t))(t)&&(i.add(t),e("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",t,l))}}getRemainingTTL(t){return this.#l.has(t)?1/0:0}#_(){const i=new a(this.#i),s=new a(this.#i);this.#b=i,this.#S=s,this.#M=(e,h,o=t.now())=>{if(s[e]=0!==h?o:0,i[e]=h,0!==h&&this.ttlAutopurge){const t=setTimeout(()=>{this.#L(e)&&this.#k(this.#f[e],"expire")},h+1);t.unref&&t.unref()}},this.#U=e=>{s[e]=0!==i[e]?t.now():0},this.#G=(t,o)=>{if(i[o]){const n=i[o],r=s[o];if(!n||!r)return;t.ttl=n,t.start=r,t.now=e||h();const a=t.now-r;t.remainingTTL=n-a}};let e=0;const h=()=>{const i=t.now();if(this.ttlResolution>0){e=i;const t=setTimeout(()=>e=0,this.ttlResolution);t.unref&&t.unref()}return i};this.getRemainingTTL=t=>{const o=this.#l.get(t);if(void 0===o)return 0;const n=i[o],r=s[o];return n&&r?n-((e||h())-r):1/0},this.#L=t=>{const o=s[t],n=i[t];return!!n&&!!o&&(e||h())-o>n}}#U=()=>{};#G=()=>{};#M=()=>{};#L=()=>!1;#R(){const t=new a(this.#i);this.#c=0,this.#y=t,this.#I=i=>{this.#c-=t[i],t[i]=0},this.#j=(t,i,s,e)=>{if(this.#O(i))return 0;if(!n(s)){if(!e)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if("function"!=typeof e)throw new TypeError("sizeCalculation must be a function");if(s=e(i,t),!n(s))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return s},this.#N=(i,s,e)=>{if(t[i]=s,this.#s){const s=this.#s-t[i];for(;this.#c>s;)this.#W(!0)}this.#c+=t[i],e&&(e.entrySize=s,e.totalCalculatedSize=this.#c)}}#I=t=>{};#N=(t,i,s)=>{};#j=(t,i,s,e)=>{if(s||e)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#C({allowStale:t=this.allowStale}={}){if(this.#a)for(let i=this.#w;this.#H(i)&&(!t&&this.#L(i)||(yield i),i!==this.#v);)i=this.#p[i]}*#D({allowStale:t=this.allowStale}={}){if(this.#a)for(let i=this.#v;this.#H(i)&&(!t&&this.#L(i)||(yield i),i!==this.#w);)i=this.#d[i]}#H(t){return void 0!==t&&this.#l.get(this.#f[t])===t}*entries(){for(const t of this.#C())void 0===this.#u[t]||void 0===this.#f[t]||this.#O(this.#u[t])||(yield[this.#f[t],this.#u[t]])}*rentries(){for(const t of this.#D())void 0===this.#u[t]||void 0===this.#f[t]||this.#O(this.#u[t])||(yield[this.#f[t],this.#u[t]])}*keys(){for(const t of this.#C()){const i=this.#f[t];void 0===i||this.#O(this.#u[t])||(yield i)}}*rkeys(){for(const t of this.#D()){const i=this.#f[t];void 0===i||this.#O(this.#u[t])||(yield i)}}*values(){for(const t of this.#C())void 0===this.#u[t]||this.#O(this.#u[t])||(yield this.#u[t])}*rvalues(){for(const t of this.#D())void 0===this.#u[t]||this.#O(this.#u[t])||(yield this.#u[t])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,i={}){for(const s of this.#C()){const e=this.#u[s],h=this.#O(e)?e.i:e;if(void 0!==h&&t(h,this.#f[s],this))return this.get(this.#f[s],i)}}forEach(t,i=this){for(const s of this.#C()){const e=this.#u[s],h=this.#O(e)?e.i:e;void 0!==h&&t.call(i,h,this.#f[s],this)}}rforEach(t,i=this){for(const s of this.#D()){const e=this.#u[s],h=this.#O(e)?e.i:e;void 0!==h&&t.call(i,h,this.#f[s],this)}}purgeStale(){let t=!1;for(const i of this.#D({allowStale:!0}))this.#L(i)&&(this.#k(this.#f[i],"expire"),t=!0);return t}info(i){const s=this.#l.get(i);if(void 0===s)return;const e=this.#u[s],h=this.#O(e)?e.i:e;if(void 0===h)return;const o={value:h};if(this.#b&&this.#S){const i=this.#b[s],e=this.#S[s];if(i&&e){const s=i-(t.now()-e);o.ttl=s,o.start=Date.now()}}return this.#y&&(o.size=this.#y[s]),o}dump(){const i=[];for(const s of this.#C({allowStale:!0})){const e=this.#f[s],h=this.#u[s],o=this.#O(h)?h.i:h;if(void 0===o||void 0===e)continue;const n={value:o};if(this.#b&&this.#S){n.ttl=this.#b[s];const i=t.now()-this.#S[s];n.start=Math.floor(Date.now()-i)}this.#y&&(n.size=this.#y[s]),i.unshift([e,n])}return i}load(i){this.clear();for(const[s,e]of i){if(e.start){const i=Date.now()-e.start;e.start=t.now()-i}this.set(s,e.value,e)}}set(t,i,s={}){if(void 0===i)return this.delete(t),this;const{ttl:e=this.ttl,start:h,noDisposeOnSet:o=this.noDisposeOnSet,sizeCalculation:n=this.sizeCalculation,status:r}=s;let{noUpdateTTL:a=this.noUpdateTTL}=s;const c=this.#j(t,i,s.size||0,n);if(this.maxEntrySize&&c>this.maxEntrySize)return r&&(r.set="miss",r.maxEntrySizeExceeded=!0),this.#k(t,"set"),this;let l=0===this.#a?void 0:this.#l.get(t);if(void 0===l)l=0===this.#a?this.#w:0!==this.#m.length?this.#m.pop():this.#a===this.#i?this.#W(!1):this.#a,this.#f[l]=t,this.#u[l]=i,this.#l.set(t,l),this.#d[this.#w]=l,this.#p[l]=this.#w,this.#w=l,this.#a++,this.#N(l,c,r),r&&(r.set="add"),a=!1,this.#x&&this.#h?.(i,t,"add");else{this.#F(l);const s=this.#u[l];if(i!==s){if(this.#A&&this.#O(s)){s.h.abort(new Error("replaced"));const{i:i}=s;void 0===i||o||(this.#T&&this.#e?.(i,t,"set"),this.#z&&this.#g?.push([i,t,"set"]))}else o||(this.#T&&this.#e?.(s,t,"set"),this.#z&&this.#g?.push([s,t,"set"]));if(this.#I(l),this.#N(l,c,r),this.#u[l]=i,r){r.set="replace";const t=s&&this.#O(s)?s.i:s;void 0!==t&&(r.oldValue=t)}}else r&&(r.set="update");this.#x&&this.onInsert?.(i,t,i===s?"update":"replace")}if(0===e||this.#b||this.#_(),this.#b&&(a||this.#M(l,e,h),r&&this.#G(r,l)),!o&&this.#z&&this.#g){const t=this.#g;let i;for(;i=t?.shift();)this.#o?.(...i)}return this}pop(){try{for(;this.#a;){const t=this.#u[this.#v];if(this.#W(!0),this.#O(t)){if(t.i)return t.i}else if(void 0!==t)return t}}finally{if(this.#z&&this.#g){const t=this.#g;let i;for(;i=t?.shift();)this.#o?.(...i)}}}#W(t){const i=this.#v,s=this.#f[i],e=this.#u[i];return this.#A&&this.#O(e)?e.h.abort(new Error("evicted")):(this.#T||this.#z)&&(this.#T&&this.#e?.(e,s,"evict"),this.#z&&this.#g?.push([e,s,"evict"])),this.#I(i),t&&(this.#f[i]=void 0,this.#u[i]=void 0,this.#m.push(i)),1===this.#a?(this.#v=this.#w=0,this.#m.length=0):this.#v=this.#d[i],this.#l.delete(s),this.#a--,i}has(t,i={}){const{updateAgeOnHas:s=this.updateAgeOnHas,status:e}=i,h=this.#l.get(t);if(void 0!==h){const t=this.#u[h];if(this.#O(t)&&void 0===t.i)return!1;if(!this.#L(h))return s&&this.#U(h),e&&(e.has="hit",this.#G(e,h)),!0;e&&(e.has="stale",this.#G(e,h))}else e&&(e.has="miss");return!1}peek(t,i={}){const{allowStale:s=this.allowStale}=i,e=this.#l.get(t);if(void 0===e||!s&&this.#L(e))return;const h=this.#u[e];return this.#O(h)?h.i:h}#E(t,i,s,e){const o=void 0===i?void 0:this.#u[i];if(this.#O(o))return o;const n=new h,{signal:r}=s;r?.addEventListener("abort",()=>n.abort(r.reason),{signal:n.signal});const a={signal:n.signal,options:s,context:e},c=(e,h=!1)=>{const{aborted:o}=n.signal,r=s.ignoreFetchAbort&&void 0!==e;if(s.status&&(o&&!h?(s.status.fetchAborted=!0,s.status.fetchError=n.signal.reason,r&&(s.status.fetchAbortIgnored=!0)):s.status.fetchResolved=!0),o&&!r&&!h)return l(n.signal.reason);const c=f;return this.#u[i]===f&&(void 0===e?c.i?this.#u[i]=c.i:this.#k(t,"fetch"):(s.status&&(s.status.fetchUpdated=!0),this.set(t,e,a.options))),e},l=e=>{const{aborted:h}=n.signal,o=h&&s.allowStaleOnFetchAbort,r=o||s.allowStaleOnFetchRejection,a=r||s.noDeleteOnFetchRejection,c=f;if(this.#u[i]===f&&(a&&void 0!==c.i?o||(this.#u[i]=c.i):this.#k(t,"fetch")),r)return s.status&&void 0!==c.i&&(s.status.returnedStale=!0),c.i;if(c.o===c)throw e};s.status&&(s.status.fetchDispatched=!0);const f=new Promise((i,e)=>{const h=this.#n?.(t,o,a);h&&h instanceof Promise&&h.then(t=>i(void 0===t?void 0:t),e),n.signal.addEventListener("abort",()=>{s.ignoreFetchAbort&&!s.allowStaleOnFetchAbort||(i(void 0),s.allowStaleOnFetchAbort&&(i=t=>c(t,!0)))})}).then(c,t=>(s.status&&(s.status.fetchRejected=!0,s.status.fetchError=t),l(t))),u=Object.assign(f,{h:n,i:o,o:void 0});return void 0===i?(this.set(t,u,{...a.options,status:void 0}),i=this.#l.get(t)):this.#u[i]=u,u}#O(t){if(!this.#A)return!1;const i=t;return!!i&&i instanceof Promise&&i.hasOwnProperty("__staleWhileFetching")&&i.h instanceof h}async fetch(t,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:e=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,ttl:o=this.ttl,noDisposeOnSet:n=this.noDisposeOnSet,size:r=0,sizeCalculation:a=this.sizeCalculation,noUpdateTTL:c=this.noUpdateTTL,noDeleteOnFetchRejection:l=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:f=this.allowStaleOnFetchRejection,ignoreFetchAbort:u=this.ignoreFetchAbort,allowStaleOnFetchAbort:d=this.allowStaleOnFetchAbort,context:p,forceRefresh:v=!1,status:w,signal:m}=i;if(!this.#A)return w&&(w.fetch="get"),this.get(t,{allowStale:s,updateAgeOnGet:e,noDeleteOnStaleGet:h,status:w});const g={allowStale:s,updateAgeOnGet:e,noDeleteOnStaleGet:h,ttl:o,noDisposeOnSet:n,size:r,sizeCalculation:a,noUpdateTTL:c,noDeleteOnFetchRejection:l,allowStaleOnFetchRejection:f,allowStaleOnFetchAbort:d,ignoreFetchAbort:u,status:w,signal:m};let y=this.#l.get(t);if(void 0===y){w&&(w.fetch="miss");const i=this.#E(t,y,g,p);return i.o=i}{const i=this.#u[y];if(this.#O(i)){const t=s&&void 0!==i.i;return w&&(w.fetch="inflight",t&&(w.returnedStale=!0)),t?i.i:i.o=i}const h=this.#L(y);if(!v&&!h)return w&&(w.fetch="hit"),this.#F(y),e&&this.#U(y),w&&this.#G(w,y),i;const o=this.#E(t,y,g,p),n=void 0!==o.i&&s;return w&&(w.fetch=h?"stale":"refresh",n&&h&&(w.returnedStale=!0)),n?o.i:o.o=o}}async forceFetch(t,i={}){const s=await this.fetch(t,i);if(void 0===s)throw new Error("fetch() returned undefined");return s}memo(t,i={}){const s=this.#r;if(!s)throw new Error("no memoMethod provided to constructor");const{context:e,forceRefresh:h,...o}=i,n=this.get(t,o);if(!h&&void 0!==n)return n;const r=s(t,n,{options:o,context:e});return this.set(t,r,o),r}get(t,i={}){const{allowStale:s=this.allowStale,updateAgeOnGet:e=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,status:o}=i,n=this.#l.get(t);if(void 0!==n){const i=this.#u[n],r=this.#O(i);return o&&this.#G(o,n),this.#L(n)?(o&&(o.get="stale"),r?(o&&s&&void 0!==i.i&&(o.returnedStale=!0),s?i.i:void 0):(h||this.#k(t,"expire"),o&&s&&(o.returnedStale=!0),s?i:void 0)):(o&&(o.get="hit"),r?i.i:(this.#F(n),e&&this.#U(n),i))}o&&(o.get="miss")}#P(t,i){this.#p[i]=t,this.#d[t]=i}#F(t){t!==this.#w&&(t===this.#v?this.#v=this.#d[t]:this.#P(this.#p[t],this.#d[t]),this.#P(this.#w,t),this.#w=t)}delete(t){return this.#k(t,"delete")}#k(t,i){let s=!1;if(0!==this.#a){const e=this.#l.get(t);if(void 0!==e)if(s=!0,1===this.#a)this.#B(i);else{this.#I(e);const s=this.#u[e];if(this.#O(s)?s.h.abort(new Error("deleted")):(this.#T||this.#z)&&(this.#T&&this.#e?.(s,t,i),this.#z&&this.#g?.push([s,t,i])),this.#l.delete(t),this.#f[e]=void 0,this.#u[e]=void 0,e===this.#w)this.#w=this.#p[e];else if(e===this.#v)this.#v=this.#d[e];else{const t=this.#p[e];this.#d[t]=this.#d[e];const i=this.#d[e];this.#p[i]=this.#p[e]}this.#a--,this.#m.push(e)}}if(this.#z&&this.#g?.length){const t=this.#g;let i;for(;i=t?.shift();)this.#o?.(...i)}return s}clear(){return this.#B("delete")}#B(t){for(const i of this.#D({allowStale:!0})){const s=this.#u[i];if(this.#O(s))s.h.abort(new Error("deleted"));else{const e=this.#f[i];this.#T&&this.#e?.(s,e,t),this.#z&&this.#g?.push([s,e,t])}}if(this.#l.clear(),this.#u.fill(void 0),this.#f.fill(void 0),this.#b&&this.#S&&(this.#b.fill(0),this.#S.fill(0)),this.#y&&this.#y.fill(0),this.#v=0,this.#w=0,this.#m.length=0,this.#c=0,this.#a=0,this.#z&&this.#g){const t=this.#g;let i;for(;i=t?.shift();)this.#o?.(...i)}}}export{l as L};
