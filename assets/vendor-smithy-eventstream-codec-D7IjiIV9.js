import{C as e}from"./vendor-aws-crypto-crc32-CfOvG1-N.js";import{t,f as r}from"./vendor-smithy-util-hex-encoding-DhdgocZN.js";class s{constructor(e){if(this.bytes=e,8!==e.byteLength)throw new Error("Int64 buffers must be exactly 8 bytes")}static fromNumber(e){if(e>0x8000000000000000||e<-0x8000000000000000)throw new Error(`${e} is too large (or, if negative, too small) to represent as an Int64`);const t=new Uint8Array(8);for(let r=7,s=Math.abs(Math.round(e));r>-1&&s>0;r--,s/=256)t[r]=s;return e<0&&a(t),new s(t)}valueOf(){const e=this.bytes.slice(0),r=128&e[0];return r&&a(e),parseInt(t(e),16)*(r?-1:1)}toString(){return String(this.valueOf())}}function a(e){for(let t=0;t<8;t++)e[t]^=255;for(let t=7;t>-1&&(e[t]++,0===e[t]);t--);}class n{constructor(e,t){this.toUtf8=e,this.fromUtf8=t}format(e){const t=[];for(const a of Object.keys(e)){const r=this.fromUtf8(a);t.push(Uint8Array.from([r.byteLength]),r,this.formatHeaderValue(e[a]))}const r=new Uint8Array(t.reduce((e,t)=>e+t.byteLength,0));let s=0;for(const a of t)r.set(a,s),s+=a.byteLength;return r}formatHeaderValue(e){switch(e.type){case"boolean":return Uint8Array.from([e.value?0:1]);case"byte":return Uint8Array.from([2,e.value]);case"short":const t=new DataView(new ArrayBuffer(3));return t.setUint8(0,3),t.setInt16(1,e.value,!1),new Uint8Array(t.buffer);case"integer":const a=new DataView(new ArrayBuffer(5));return a.setUint8(0,4),a.setInt32(1,e.value,!1),new Uint8Array(a.buffer);case"long":const n=new Uint8Array(9);return n[0]=5,n.set(e.value.bytes,1),n;case"binary":const o=new DataView(new ArrayBuffer(3+e.value.byteLength));o.setUint8(0,6),o.setUint16(1,e.value.byteLength,!1);const i=new Uint8Array(o.buffer);return i.set(e.value,3),i;case"string":const c=this.fromUtf8(e.value),f=new DataView(new ArrayBuffer(3+c.byteLength));f.setUint8(0,7),f.setUint16(1,c.byteLength,!1);const u=new Uint8Array(f.buffer);return u.set(c,3),u;case"timestamp":const y=new Uint8Array(9);return y[0]=8,y.set(s.fromNumber(e.value.valueOf()).bytes,1),y;case"uuid":if(!m.test(e.value))throw new Error(`Invalid UUID received: ${e.value}`);const h=new Uint8Array(17);return h[0]=9,h.set(r(e.value.replace(/\-/g,"")),1),h}}parse(e){const r={};let a=0;for(;a<e.byteLength;){const n=e.getUint8(a++),o=this.toUtf8(new Uint8Array(e.buffer,e.byteOffset+a,n));switch(a+=n,e.getUint8(a++)){case 0:r[o]={type:c,value:!0};break;case 1:r[o]={type:c,value:!1};break;case 2:r[o]={type:f,value:e.getInt8(a++)};break;case 3:r[o]={type:u,value:e.getInt16(a,!1)},a+=2;break;case 4:r[o]={type:y,value:e.getInt32(a,!1)},a+=4;break;case 5:r[o]={type:h,value:new s(new Uint8Array(e.buffer,e.byteOffset+a,8))},a+=8;break;case 6:const n=e.getUint16(a,!1);a+=2,r[o]={type:l,value:new Uint8Array(e.buffer,e.byteOffset+a,n)},a+=n;break;case 7:const i=e.getUint16(a,!1);a+=2,r[o]={type:b,value:this.toUtf8(new Uint8Array(e.buffer,e.byteOffset+a,i))},a+=i;break;case 8:r[o]={type:d,value:new Date(new s(new Uint8Array(e.buffer,e.byteOffset+a,8)).valueOf())},a+=8;break;case 9:const m=new Uint8Array(e.buffer,e.byteOffset+a,16);a+=16,r[o]={type:g,value:`${t(m.subarray(0,4))}-${t(m.subarray(4,6))}-${t(m.subarray(6,8))}-${t(m.subarray(8,10))}-${t(m.subarray(10))}`};break;default:throw new Error("Unrecognized header type tag")}}return r}}var o,i;(i=o||(o={}))[i.boolTrue=0]="boolTrue",i[i.boolFalse=1]="boolFalse",i[i.byte=2]="byte",i[i.short=3]="short",i[i.integer=4]="integer",i[i.long=5]="long",i[i.byteArray=6]="byteArray",i[i.string=7]="string",i[i.timestamp=8]="timestamp",i[i.uuid=9]="uuid";const c="boolean",f="byte",u="short",y="integer",h="long",l="binary",b="string",d="timestamp",g="uuid",m=/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;class w{constructor(e,t){this.headerMarshaller=new n(e,t),this.messageBuffer=[],this.isEndOfStream=!1}feed(e){this.messageBuffer.push(this.decode(e))}endOfStream(){this.isEndOfStream=!0}getMessage(){const e=this.messageBuffer.pop(),t=this.isEndOfStream;return{getMessage:()=>e,isEndOfStream:()=>t}}getAvailableMessages(){const e=this.messageBuffer;this.messageBuffer=[];const t=this.isEndOfStream;return{getMessages:()=>e,isEndOfStream:()=>t}}encode({headers:t,body:r}){const s=this.headerMarshaller.format(t),a=s.byteLength+r.byteLength+16,n=new Uint8Array(a),o=new DataView(n.buffer,n.byteOffset,n.byteLength),i=new e;return o.setUint32(0,a,!1),o.setUint32(4,s.byteLength,!1),o.setUint32(8,i.update(n.subarray(0,8)).digest(),!1),n.set(s,12),n.set(r,s.byteLength+12),o.setUint32(a-4,i.update(n.subarray(8,a-4)).digest(),!1),n}decode(t){const{headers:r,body:s}=function({byteLength:t,byteOffset:r,buffer:s}){if(t<16)throw new Error("Provided message too short to accommodate event stream message overhead");const a=new DataView(s,r,t),n=a.getUint32(0,!1);if(t!==n)throw new Error("Reported message length does not match received message length");const o=a.getUint32(4,!1),i=a.getUint32(8,!1),c=a.getUint32(t-4,!1),f=(new e).update(new Uint8Array(s,r,8));if(i!==f.digest())throw new Error(`The prelude checksum specified in the message (${i}) does not match the calculated CRC32 checksum (${f.digest()})`);if(f.update(new Uint8Array(s,r+8,t-12)),c!==f.digest())throw new Error(`The message checksum (${f.digest()}) did not match the expected value of ${c}`);return{headers:new DataView(s,r+8+4,o),body:new Uint8Array(s,r+8+4+o,n-o-16)}}(t);return{headers:this.headerMarshaller.parse(r),body:s}}formatHeaders(e){return this.headerMarshaller.format(e)}}class p{constructor(e){this.options=e}[Symbol.asyncIterator](){return this.asyncIterator()}async*asyncIterator(){for await(const e of this.options.inputStream){const t=this.options.decoder.decode(e);yield t}}}class U{constructor(e){this.options=e}[Symbol.asyncIterator](){return this.asyncIterator()}async*asyncIterator(){for await(const e of this.options.messageStream){const t=this.options.encoder.encode(e);yield t}this.options.includeEndFrame&&(yield new Uint8Array(0))}}class v{constructor(e){this.options=e}[Symbol.asyncIterator](){return this.asyncIterator()}async*asyncIterator(){for await(const e of this.options.messageStream){const t=await this.options.deserializer(e);void 0!==t&&(yield t)}}}class A{constructor(e){this.options=e}[Symbol.asyncIterator](){return this.asyncIterator()}async*asyncIterator(){for await(const e of this.options.inputStream){const t=this.options.serializer(e);yield t}}}export{w as E,p as M,v as S,U as a,A as b};
