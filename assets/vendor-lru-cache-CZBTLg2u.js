const t="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,e=new Set,i="object"==typeof process&&process?process:{},s=(t,e,s,o)=>{"function"==typeof i.emitWarning&&i.emitWarning(t,e,s,o)};let o=globalThis.AbortController,h=globalThis.AbortSignal;if(void 0===o){h=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(t,e){this._onabort.push(e)}},o=class{constructor(){e()}signal=new h;abort(t){if(!this.signal.aborted){this.signal.reason=t,this.signal.aborted=!0;for(const e of this.signal._onabort)e(t);this.signal.onabort?.(t)}}};let t="1"!==i.env?.LRU_CACHE_IGNORE_AC_WARNING;const e=()=>{t&&(t=!1,s("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",e))}}const n=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),a=t=>n(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?r:null:null;class r extends Array{constructor(t){super(t),this.fill(0)}}class l{heap;length;static#t=!1;static create(t){const e=a(t);if(!e)return[];l.#t=!0;const i=new l(t,e);return l.#t=!1,i}constructor(t,e){if(!l.#t)throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}}class c{#e;#i;#s;#o;#h;#n;#a;#r;get perf(){return this.#r}ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#l;#c;#d;#u;#f;#p;#g;#v;#m;#S;#y;#z;#w;#T;#L;#F;#x;#A;#_;static unsafeExposeInternals(t){return{starts:t.#w,ttls:t.#T,autopurgeTimers:t.#L,sizes:t.#z,keyMap:t.#d,keyList:t.#u,valList:t.#f,next:t.#p,prev:t.#g,get head(){return t.#v},get tail(){return t.#m},free:t.#S,isBackgroundFetch:e=>t.#k(e),backgroundFetch:(e,i,s,o)=>t.#b(e,i,s,o),moveToTail:e=>t.#O(e),indexes:e=>t.#E(e),rindexes:e=>t.#D(e),isStale:e=>t.#M(e)}}get max(){return this.#e}get maxSize(){return this.#i}get calculatedSize(){return this.#c}get size(){return this.#l}get fetchMethod(){return this.#n}get memoMethod(){return this.#a}get dispose(){return this.#s}get onInsert(){return this.#o}get disposeAfter(){return this.#h}constructor(i){const{max:o=0,ttl:h,ttlResolution:r=1,ttlAutopurge:d,updateAgeOnGet:u,updateAgeOnHas:f,allowStale:p,dispose:g,onInsert:v,disposeAfter:m,noDisposeOnSet:S,noUpdateTTL:y,maxSize:z=0,maxEntrySize:w=0,sizeCalculation:T,fetchMethod:L,memoMethod:F,noDeleteOnFetchRejection:x,noDeleteOnStaleGet:A,allowStaleOnFetchRejection:_,allowStaleOnFetchAbort:k,ignoreFetchAbort:b,perf:O}=i;if(void 0!==O&&"function"!=typeof O?.now)throw new TypeError("perf option must have a now() method if specified");if(this.#r=O??t,0!==o&&!n(o))throw new TypeError("max option must be a nonnegative integer");const E=o?a(o):Array;if(!E)throw new Error("invalid max value: "+o);if(this.#e=o,this.#i=z,this.maxEntrySize=w||this.#i,this.sizeCalculation=T,this.sizeCalculation){if(!this.#i&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw new TypeError("sizeCalculation set to non-function")}if(void 0!==F&&"function"!=typeof F)throw new TypeError("memoMethod must be a function if defined");if(this.#a=F,void 0!==L&&"function"!=typeof L)throw new TypeError("fetchMethod must be a function if specified");if(this.#n=L,this.#x=!!L,this.#d=new Map,this.#u=new Array(o).fill(void 0),this.#f=new Array(o).fill(void 0),this.#p=new E(o),this.#g=new E(o),this.#v=0,this.#m=0,this.#S=l.create(o),this.#l=0,this.#c=0,"function"==typeof g&&(this.#s=g),"function"==typeof v&&(this.#o=v),"function"==typeof m?(this.#h=m,this.#y=[]):(this.#h=void 0,this.#y=void 0),this.#F=!!this.#s,this.#_=!!this.#o,this.#A=!!this.#h,this.noDisposeOnSet=!!S,this.noUpdateTTL=!!y,this.noDeleteOnFetchRejection=!!x,this.allowStaleOnFetchRejection=!!_,this.allowStaleOnFetchAbort=!!k,this.ignoreFetchAbort=!!b,0!==this.maxEntrySize){if(0!==this.#i&&!n(this.#i))throw new TypeError("maxSize must be a positive integer if specified");if(!n(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.#I()}if(this.allowStale=!!p,this.noDeleteOnStaleGet=!!A,this.updateAgeOnGet=!!u,this.updateAgeOnHas=!!f,this.ttlResolution=n(r)||0===r?r:1,this.ttlAutopurge=!!d,this.ttl=h||0,this.ttl){if(!n(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.#C()}if(0===this.#e&&0===this.ttl&&0===this.#i)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#e&&!this.#i){const t="LRU_CACHE_UNBOUNDED";(t=>!e.has(t))(t)&&(e.add(t),s("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",t,c))}}getRemainingTTL(t){return this.#d.has(t)?1/0:0}#C(){const t=new r(this.#e),e=new r(this.#e);this.#T=t,this.#w=e;const i=this.ttlAutopurge?new Array(this.#e):void 0;this.#L=i,this.#R=(s,o,h=this.#r.now())=>{if(e[s]=0!==o?h:0,t[s]=o,i?.[s]&&(clearTimeout(i[s]),i[s]=void 0),0!==o&&i){const t=setTimeout(()=>{this.#M(s)&&this.#W(this.#u[s],"expire")},o+1);t.unref&&t.unref(),i[s]=t}},this.#B=i=>{e[i]=0!==t[i]?this.#r.now():0},this.#G=(i,h)=>{if(t[h]){const n=t[h],a=e[h];if(!n||!a)return;i.ttl=n,i.start=a,i.now=s||o();const r=i.now-a;i.remainingTTL=n-r}};let s=0;const o=()=>{const t=this.#r.now();if(this.ttlResolution>0){s=t;const e=setTimeout(()=>s=0,this.ttlResolution);e.unref&&e.unref()}return t};this.getRemainingTTL=i=>{const h=this.#d.get(i);if(void 0===h)return 0;const n=t[h],a=e[h];return n&&a?n-((s||o())-a):1/0},this.#M=i=>{const h=e[i],n=t[i];return!!n&&!!h&&(s||o())-h>n}}#B=()=>{};#G=()=>{};#R=()=>{};#M=()=>!1;#I(){const t=new r(this.#e);this.#c=0,this.#z=t,this.#U=e=>{this.#c-=t[e],t[e]=0},this.#j=(t,e,i,s)=>{if(this.#k(e))return 0;if(!n(i)){if(!s)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if("function"!=typeof s)throw new TypeError("sizeCalculation must be a function");if(i=s(e,t),!n(i))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return i},this.#N=(e,i,s)=>{if(t[e]=i,this.#i){const i=this.#i-t[e];for(;this.#c>i;)this.#H(!0)}this.#c+=t[e],s&&(s.entrySize=i,s.totalCalculatedSize=this.#c)}}#U=t=>{};#N=(t,e,i)=>{};#j=(t,e,i,s)=>{if(i||s)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#E({allowStale:t=this.allowStale}={}){if(this.#l)for(let e=this.#m;this.#P(e)&&(!t&&this.#M(e)||(yield e),e!==this.#v);)e=this.#g[e]}*#D({allowStale:t=this.allowStale}={}){if(this.#l)for(let e=this.#v;this.#P(e)&&(!t&&this.#M(e)||(yield e),e!==this.#m);)e=this.#p[e]}#P(t){return void 0!==t&&this.#d.get(this.#u[t])===t}*entries(){for(const t of this.#E())void 0===this.#f[t]||void 0===this.#u[t]||this.#k(this.#f[t])||(yield[this.#u[t],this.#f[t]])}*rentries(){for(const t of this.#D())void 0===this.#f[t]||void 0===this.#u[t]||this.#k(this.#f[t])||(yield[this.#u[t],this.#f[t]])}*keys(){for(const t of this.#E()){const e=this.#u[t];void 0===e||this.#k(this.#f[t])||(yield e)}}*rkeys(){for(const t of this.#D()){const e=this.#u[t];void 0===e||this.#k(this.#f[t])||(yield e)}}*values(){for(const t of this.#E())void 0===this.#f[t]||this.#k(this.#f[t])||(yield this.#f[t])}*rvalues(){for(const t of this.#D())void 0===this.#f[t]||this.#k(this.#f[t])||(yield this.#f[t])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(const i of this.#E()){const s=this.#f[i],o=this.#k(s)?s.__staleWhileFetching:s;if(void 0!==o&&t(o,this.#u[i],this))return this.get(this.#u[i],e)}}forEach(t,e=this){for(const i of this.#E()){const s=this.#f[i],o=this.#k(s)?s.__staleWhileFetching:s;void 0!==o&&t.call(e,o,this.#u[i],this)}}rforEach(t,e=this){for(const i of this.#D()){const s=this.#f[i],o=this.#k(s)?s.__staleWhileFetching:s;void 0!==o&&t.call(e,o,this.#u[i],this)}}purgeStale(){let t=!1;for(const e of this.#D({allowStale:!0}))this.#M(e)&&(this.#W(this.#u[e],"expire"),t=!0);return t}info(t){const e=this.#d.get(t);if(void 0===e)return;const i=this.#f[e],s=this.#k(i)?i.__staleWhileFetching:i;if(void 0===s)return;const o={value:s};if(this.#T&&this.#w){const t=this.#T[e],i=this.#w[e];if(t&&i){const e=t-(this.#r.now()-i);o.ttl=e,o.start=Date.now()}}return this.#z&&(o.size=this.#z[e]),o}dump(){const t=[];for(const e of this.#E({allowStale:!0})){const i=this.#u[e],s=this.#f[e],o=this.#k(s)?s.__staleWhileFetching:s;if(void 0===o||void 0===i)continue;const h={value:o};if(this.#T&&this.#w){h.ttl=this.#T[e];const t=this.#r.now()-this.#w[e];h.start=Math.floor(Date.now()-t)}this.#z&&(h.size=this.#z[e]),t.unshift([i,h])}return t}load(t){this.clear();for(const[e,i]of t){if(i.start){const t=Date.now()-i.start;i.start=this.#r.now()-t}this.set(e,i.value,i)}}set(t,e,i={}){if(void 0===e)return this.delete(t),this;const{ttl:s=this.ttl,start:o,noDisposeOnSet:h=this.noDisposeOnSet,sizeCalculation:n=this.sizeCalculation,status:a}=i;let{noUpdateTTL:r=this.noUpdateTTL}=i;const l=this.#j(t,e,i.size||0,n);if(this.maxEntrySize&&l>this.maxEntrySize)return a&&(a.set="miss",a.maxEntrySizeExceeded=!0),this.#W(t,"set"),this;let c=0===this.#l?void 0:this.#d.get(t);if(void 0===c)c=0===this.#l?this.#m:0!==this.#S.length?this.#S.pop():this.#l===this.#e?this.#H(!1):this.#l,this.#u[c]=t,this.#f[c]=e,this.#d.set(t,c),this.#p[this.#m]=c,this.#g[c]=this.#m,this.#m=c,this.#l++,this.#N(c,l,a),a&&(a.set="add"),r=!1,this.#_&&this.#o?.(e,t,"add");else{this.#O(c);const i=this.#f[c];if(e!==i){if(this.#x&&this.#k(i)){i.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:e}=i;void 0===e||h||(this.#F&&this.#s?.(e,t,"set"),this.#A&&this.#y?.push([e,t,"set"]))}else h||(this.#F&&this.#s?.(i,t,"set"),this.#A&&this.#y?.push([i,t,"set"]));if(this.#U(c),this.#N(c,l,a),this.#f[c]=e,a){a.set="replace";const t=i&&this.#k(i)?i.__staleWhileFetching:i;void 0!==t&&(a.oldValue=t)}}else a&&(a.set="update");this.#_&&this.onInsert?.(e,t,e===i?"update":"replace")}if(0===s||this.#T||this.#C(),this.#T&&(r||this.#R(c,s,o),a&&this.#G(a,c)),!h&&this.#A&&this.#y){const t=this.#y;let e;for(;e=t?.shift();)this.#h?.(...e)}return this}pop(){try{for(;this.#l;){const t=this.#f[this.#v];if(this.#H(!0),this.#k(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(void 0!==t)return t}}finally{if(this.#A&&this.#y){const t=this.#y;let e;for(;e=t?.shift();)this.#h?.(...e)}}}#H(t){const e=this.#v,i=this.#u[e],s=this.#f[e];return this.#x&&this.#k(s)?s.__abortController.abort(new Error("evicted")):(this.#F||this.#A)&&(this.#F&&this.#s?.(s,i,"evict"),this.#A&&this.#y?.push([s,i,"evict"])),this.#U(e),this.#L?.[e]&&(clearTimeout(this.#L[e]),this.#L[e]=void 0),t&&(this.#u[e]=void 0,this.#f[e]=void 0,this.#S.push(e)),1===this.#l?(this.#v=this.#m=0,this.#S.length=0):this.#v=this.#p[e],this.#d.delete(i),this.#l--,e}has(t,e={}){const{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e,o=this.#d.get(t);if(void 0!==o){const t=this.#f[o];if(this.#k(t)&&void 0===t.__staleWhileFetching)return!1;if(!this.#M(o))return i&&this.#B(o),s&&(s.has="hit",this.#G(s,o)),!0;s&&(s.has="stale",this.#G(s,o))}else s&&(s.has="miss");return!1}peek(t,e={}){const{allowStale:i=this.allowStale}=e,s=this.#d.get(t);if(void 0===s||!i&&this.#M(s))return;const o=this.#f[s];return this.#k(o)?o.__staleWhileFetching:o}#b(t,e,i,s){const h=void 0===e?void 0:this.#f[e];if(this.#k(h))return h;const n=new o,{signal:a}=i;a?.addEventListener("abort",()=>n.abort(a.reason),{signal:n.signal});const r={signal:n.signal,options:i,context:s},l=(s,o=!1)=>{const{aborted:h}=n.signal,a=i.ignoreFetchAbort&&void 0!==s;if(i.status&&(h&&!o?(i.status.fetchAborted=!0,i.status.fetchError=n.signal.reason,a&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),h&&!a&&!o)return c(n.signal.reason);const l=d,u=this.#f[e];return(u===d||a&&o&&void 0===u)&&(void 0===s?void 0!==l.__staleWhileFetching?this.#f[e]=l.__staleWhileFetching:this.#W(t,"fetch"):(i.status&&(i.status.fetchUpdated=!0),this.set(t,s,r.options))),s},c=s=>{const{aborted:o}=n.signal,h=o&&i.allowStaleOnFetchAbort,a=h||i.allowStaleOnFetchRejection,r=a||i.noDeleteOnFetchRejection,l=d;if(this.#f[e]===d&&(r&&void 0!==l.__staleWhileFetching?h||(this.#f[e]=l.__staleWhileFetching):this.#W(t,"fetch")),a)return i.status&&void 0!==l.__staleWhileFetching&&(i.status.returnedStale=!0),l.__staleWhileFetching;if(l.__returned===l)throw s};i.status&&(i.status.fetchDispatched=!0);const d=new Promise((e,s)=>{const o=this.#n?.(t,h,r);o&&o instanceof Promise&&o.then(t=>e(void 0===t?void 0:t),s),n.signal.addEventListener("abort",()=>{i.ignoreFetchAbort&&!i.allowStaleOnFetchAbort||(e(void 0),i.allowStaleOnFetchAbort&&(e=t=>l(t,!0)))})}).then(l,t=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=t),c(t))),u=Object.assign(d,{__abortController:n,__staleWhileFetching:h,__returned:void 0});return void 0===e?(this.set(t,u,{...r.options,status:void 0}),e=this.#d.get(t)):this.#f[e]=u,u}#k(t){if(!this.#x)return!1;const e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof o}async fetch(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:o=this.noDeleteOnStaleGet,ttl:h=this.ttl,noDisposeOnSet:n=this.noDisposeOnSet,size:a=0,sizeCalculation:r=this.sizeCalculation,noUpdateTTL:l=this.noUpdateTTL,noDeleteOnFetchRejection:c=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:d=this.allowStaleOnFetchRejection,ignoreFetchAbort:u=this.ignoreFetchAbort,allowStaleOnFetchAbort:f=this.allowStaleOnFetchAbort,context:p,forceRefresh:g=!1,status:v,signal:m}=e;if(!this.#x)return v&&(v.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:o,status:v});const S={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:o,ttl:h,noDisposeOnSet:n,size:a,sizeCalculation:r,noUpdateTTL:l,noDeleteOnFetchRejection:c,allowStaleOnFetchRejection:d,allowStaleOnFetchAbort:f,ignoreFetchAbort:u,status:v,signal:m};let y=this.#d.get(t);if(void 0===y){v&&(v.fetch="miss");const e=this.#b(t,y,S,p);return e.__returned=e}{const e=this.#f[y];if(this.#k(e)){const t=i&&void 0!==e.__staleWhileFetching;return v&&(v.fetch="inflight",t&&(v.returnedStale=!0)),t?e.__staleWhileFetching:e.__returned=e}const o=this.#M(y);if(!g&&!o)return v&&(v.fetch="hit"),this.#O(y),s&&this.#B(y),v&&this.#G(v,y),e;const h=this.#b(t,y,S,p),n=void 0!==h.__staleWhileFetching&&i;return v&&(v.fetch=o?"stale":"refresh",n&&o&&(v.returnedStale=!0)),n?h.__staleWhileFetching:h.__returned=h}}async forceFetch(t,e={}){const i=await this.fetch(t,e);if(void 0===i)throw new Error("fetch() returned undefined");return i}memo(t,e={}){const i=this.#a;if(!i)throw new Error("no memoMethod provided to constructor");const{context:s,forceRefresh:o,...h}=e,n=this.get(t,h);if(!o&&void 0!==n)return n;const a=i(t,n,{options:h,context:s});return this.set(t,a,h),a}get(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:o=this.noDeleteOnStaleGet,status:h}=e,n=this.#d.get(t);if(void 0!==n){const e=this.#f[n],a=this.#k(e);return h&&this.#G(h,n),this.#M(n)?(h&&(h.get="stale"),a?(h&&i&&void 0!==e.__staleWhileFetching&&(h.returnedStale=!0),i?e.__staleWhileFetching:void 0):(o||this.#W(t,"expire"),h&&i&&(h.returnedStale=!0),i?e:void 0)):(h&&(h.get="hit"),a?e.__staleWhileFetching:(this.#O(n),s&&this.#B(n),e))}h&&(h.get="miss")}#q(t,e){this.#g[e]=t,this.#p[t]=e}#O(t){t!==this.#m&&(t===this.#v?this.#v=this.#p[t]:this.#q(this.#g[t],this.#p[t]),this.#q(this.#m,t),this.#m=t)}delete(t){return this.#W(t,"delete")}#W(t,e){let i=!1;if(0!==this.#l){const s=this.#d.get(t);if(void 0!==s)if(this.#L?.[s]&&(clearTimeout(this.#L?.[s]),this.#L[s]=void 0),i=!0,1===this.#l)this.#V(e);else{this.#U(s);const i=this.#f[s];if(this.#k(i)?i.__abortController.abort(new Error("deleted")):(this.#F||this.#A)&&(this.#F&&this.#s?.(i,t,e),this.#A&&this.#y?.push([i,t,e])),this.#d.delete(t),this.#u[s]=void 0,this.#f[s]=void 0,s===this.#m)this.#m=this.#g[s];else if(s===this.#v)this.#v=this.#p[s];else{const t=this.#g[s];this.#p[t]=this.#p[s];const e=this.#p[s];this.#g[e]=this.#g[s]}this.#l--,this.#S.push(s)}}if(this.#A&&this.#y?.length){const t=this.#y;let e;for(;e=t?.shift();)this.#h?.(...e)}return i}clear(){return this.#V("delete")}#V(t){for(const e of this.#D({allowStale:!0})){const i=this.#f[e];if(this.#k(i))i.__abortController.abort(new Error("deleted"));else{const s=this.#u[e];this.#F&&this.#s?.(i,s,t),this.#A&&this.#y?.push([i,s,t])}}if(this.#d.clear(),this.#f.fill(void 0),this.#u.fill(void 0),this.#T&&this.#w){this.#T.fill(0),this.#w.fill(0);for(const t of this.#L??[])void 0!==t&&clearTimeout(t);this.#L?.fill(void 0)}if(this.#z&&this.#z.fill(0),this.#v=0,this.#m=0,this.#S.length=0,this.#c=0,this.#l=0,this.#A&&this.#y){const t=this.#y;let e;for(;e=t?.shift();)this.#h?.(...e)}}}export{c as L};
