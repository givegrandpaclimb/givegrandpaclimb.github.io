import{t,f as e}from"./vendor-smithy-util-hex-encoding-CCWyKaJD.js";import{a as n,f as r}from"./vendor-smithy-util-utf8-xqXQEPn9.js";import{i as s}from"./vendor-smithy-is-array-buffer-DPIx95ez.js";import{a as i}from"./vendor-smithy-protocol-http-BM_qqgGS.js";import{e as a}from"./vendor-smithy-util-uri-escape-CT7eTZv_.js";import{n as o}from"./vendor-smithy-util-middleware-CiYOBhdT.js";const c="X-Amz-Date",g="X-Amz-Signature",h="X-Amz-Security-Token",u="authorization",f=c.toLowerCase(),w=[u,f,"date"],l=g.toLowerCase(),y="x-amz-content-sha256",d=h.toLowerCase(),m={authorization:!0,"cache-control":!0,connection:!0,expect:!0,from:!0,"keep-alive":!0,"max-forwards":!0,pragma:!0,referer:!0,te:!0,trailer:!0,"transfer-encoding":!0,upgrade:!0,"user-agent":!0,"x-amzn-trace-id":!0},p=/^proxy-/,b=/^sec-/,$="AWS4-HMAC-SHA256",D="AWS4-HMAC-SHA256-PAYLOAD",A="aws4_request",v={},S=[],j=(t,e,n)=>`${t}/${e}/${n}/${A}`,U=(t,e,r)=>{const s=new t(e);return s.update(n(r)),s.digest()},H=({headers:t},e,n)=>{const r={};for(const s of Object.keys(t).sort()){if(null==t[s])continue;const i=s.toLowerCase();(i in m||e?.has(i)||p.test(i)||b.test(i))&&(!n||n&&!n.has(i))||(r[i]=t[s].trim().replace(/\s+/g," "))}return r},x=async({headers:e,body:r},i)=>{for(const t of Object.keys(e))if(t.toLowerCase()===y)return e[t];if(null==r)return"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";if("string"==typeof r||ArrayBuffer.isView(r)||s(r)){const e=new i;return e.update(n(r)),t(await e.digest())}return"UNSIGNED-PAYLOAD"};class O{format(t){const e=[];for(const i of Object.keys(t)){const n=r(i);e.push(Uint8Array.from([n.byteLength]),n,this.formatHeaderValue(t[i]))}const n=new Uint8Array(e.reduce((t,e)=>t+e.byteLength,0));let s=0;for(const r of e)n.set(r,s),s+=r.byteLength;return n}formatHeaderValue(t){switch(t.type){case"boolean":return Uint8Array.from([t.value?0:1]);case"byte":return Uint8Array.from([2,t.value]);case"short":const n=new DataView(new ArrayBuffer(3));return n.setUint8(0,3),n.setInt16(1,t.value,!1),new Uint8Array(n.buffer);case"integer":const s=new DataView(new ArrayBuffer(5));return s.setUint8(0,4),s.setInt32(1,t.value,!1),new Uint8Array(s.buffer);case"long":const i=new Uint8Array(9);return i[0]=5,i.set(t.value.bytes,1),i;case"binary":const a=new DataView(new ArrayBuffer(3+t.value.byteLength));a.setUint8(0,6),a.setUint16(1,t.value.byteLength,!1);const o=new Uint8Array(a.buffer);return o.set(t.value,3),o;case"string":const c=r(t.value),g=new DataView(new ArrayBuffer(3+c.byteLength));g.setUint8(0,7),g.setUint16(1,c.byteLength,!1);const h=new Uint8Array(g.buffer);return h.set(c,3),h;case"timestamp":const u=new Uint8Array(9);return u[0]=8,u.set(z.fromNumber(t.value.valueOf()).bytes,1),u;case"uuid":if(!E.test(t.value))throw new Error(`Invalid UUID received: ${t.value}`);const f=new Uint8Array(17);return f[0]=9,f.set(e(t.value.replace(/\-/g,"")),1),f}}}var R,C;(C=R||(R={}))[C.boolTrue=0]="boolTrue",C[C.boolFalse=1]="boolFalse",C[C.byte=2]="byte",C[C.short=3]="short",C[C.integer=4]="integer",C[C.long=5]="long",C[C.byteArray=6]="byteArray",C[C.string=7]="string",C[C.timestamp=8]="timestamp",C[C.uuid=9]="uuid";const E=/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;class z{constructor(t){if(this.bytes=t,8!==t.byteLength)throw new Error("Int64 buffers must be exactly 8 bytes")}static fromNumber(t){if(t>0x8000000000000000||t<-0x8000000000000000)throw new Error(`${t} is too large (or, if negative, too small) to represent as an Int64`);const e=new Uint8Array(8);for(let n=7,r=Math.abs(Math.round(t));n>-1&&r>0;n--,r/=256)e[n]=r;return t<0&&I(e),new z(e)}valueOf(){const e=this.bytes.slice(0),n=128&e[0];return n&&I(e),parseInt(t(e),16)*(n?-1:1)}toString(){return String(this.valueOf())}}function I(t){for(let e=0;e<8;e++)t[e]^=255;for(let e=7;e>-1&&(t[e]++,0===t[e]);e--);}const P=t=>{t=i.clone(t);for(const e of Object.keys(t.headers))w.indexOf(e.toLowerCase())>-1&&delete t.headers[e];return t};class k{constructor({applyChecksum:t,credentials:e,region:n,service:r,sha256:s,uriEscapePath:i=!0}){this.service=r,this.sha256=s,this.uriEscapePath=i,this.applyChecksum="boolean"!=typeof t||t,this.regionProvider=o(n),this.credentialProvider=o(e)}createCanonicalRequest(t,e,n){const r=Object.keys(e).sort();return`${t.method}\n${this.getCanonicalPath(t)}\n${(({query:t={}})=>{const e=[],n={};for(const r of Object.keys(t)){if(r.toLowerCase()===l)continue;const s=a(r);e.push(s);const i=t[r];"string"==typeof i?n[s]=`${s}=${a(i)}`:Array.isArray(i)&&(n[s]=i.slice(0).reduce((t,e)=>t.concat([`${s}=${a(e)}`]),[]).sort().join("&"))}return e.sort().map(t=>n[t]).filter(t=>t).join("&")})(t)}\n${r.map(t=>`${t}:${e[t]}`).join("\n")}\n\n${r.join(";")}\n${n}`}async createStringToSign(e,r,s,i){const a=new this.sha256;a.update(n(s));const o=await a.digest();return`${i}\n${e}\n${r}\n${t(o)}`}getCanonicalPath({path:t}){if(this.uriEscapePath){const e=[];for(const r of t.split("/"))0!==r?.length&&"."!==r&&(".."===r?e.pop():e.push(r));const n=`${t?.startsWith("/")?"/":""}${e.join("/")}${e.length>0&&t?.endsWith("/")?"/":""}`;return a(n).replace(/%2F/g,"/")}return t}validateResolvedCredentials(t){if("object"!=typeof t||"string"!=typeof t.accessKeyId||"string"!=typeof t.secretAccessKey)throw new Error("Resolved credential object is not valid")}formatDate(t){const e=(n=t,(t=>"number"==typeof t?new Date(1e3*t):"string"==typeof t?Number(t)?new Date(1e3*Number(t)):new Date(t):t)(n).toISOString().replace(/\.\d{3}Z$/,"Z")).replace(/[\-:]/g,"");var n;return{longDate:e,shortDate:e.slice(0,8)}}getCanonicalHeaderList(t){return Object.keys(t).sort().join(";")}}class q extends k{constructor({applyChecksum:t,credentials:e,region:n,service:r,sha256:s,uriEscapePath:i=!0}){super({applyChecksum:t,credentials:e,region:n,service:r,sha256:s,uriEscapePath:i}),this.headerFormatter=new O}async presign(t,e={}){const{signingDate:n=new Date,expiresIn:r=3600,unsignableHeaders:s,unhoistableHeaders:a,signableHeaders:o,hoistableHeaders:u,signingRegion:f,signingService:w}=e,l=await this.credentialProvider();this.validateResolvedCredentials(l);const y=f??await this.regionProvider(),{longDate:d,shortDate:m}=this.formatDate(n);if(r>604800)return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");const p=j(m,y,w??this.service),b=((t,e={})=>{const{headers:n,query:r={}}=i.clone(t);for(const s of Object.keys(n)){const t=s.toLowerCase();("x-amz-"===t.slice(0,6)&&!e.unhoistableHeaders?.has(t)||e.hoistableHeaders?.has(t))&&(r[s]=n[s],delete n[s])}return{...t,headers:n,query:r}})(P(t),{unhoistableHeaders:a,hoistableHeaders:u});l.sessionToken&&(b.query[h]=l.sessionToken),b.query["X-Amz-Algorithm"]=$,b.query["X-Amz-Credential"]=`${l.accessKeyId}/${p}`,b.query[c]=d,b.query["X-Amz-Expires"]=r.toString(10);const D=H(b,s,o);return b.query["X-Amz-SignedHeaders"]=this.getCanonicalHeaderList(D),b.query[g]=await this.getSignature(d,p,this.getSigningKey(l,y,m,w),this.createCanonicalRequest(b,D,await x(t,this.sha256))),b}async sign(t,e){return"string"==typeof t?this.signString(t,e):t.headers&&t.payload?this.signEvent(t,e):t.message?this.signMessage(t,e):this.signRequest(t,e)}async signEvent({headers:e,payload:n},{signingDate:r=new Date,priorSignature:s,signingRegion:i,signingService:a}){const o=i??await this.regionProvider(),{shortDate:c,longDate:g}=this.formatDate(r),h=j(c,o,a??this.service),u=await x({headers:{},body:n},this.sha256),f=new this.sha256;f.update(e);const w=t(await f.digest()),l=[D,g,h,s,w,u].join("\n");return this.signString(l,{signingDate:r,signingRegion:o,signingService:a})}async signMessage(t,{signingDate:e=new Date,signingRegion:n,signingService:r}){return this.signEvent({headers:this.headerFormatter.format(t.message.headers),payload:t.message.body},{signingDate:e,signingRegion:n,signingService:r,priorSignature:t.priorSignature}).then(e=>({message:t.message,signature:e}))}async signString(e,{signingDate:r=new Date,signingRegion:s,signingService:i}={}){const a=await this.credentialProvider();this.validateResolvedCredentials(a);const o=s??await this.regionProvider(),{shortDate:c}=this.formatDate(r),g=new this.sha256(await this.getSigningKey(a,o,c,i));return g.update(n(e)),t(await g.digest())}async signRequest(t,{signingDate:e=new Date,signableHeaders:n,unsignableHeaders:r,signingRegion:s,signingService:i}={}){const a=await this.credentialProvider();this.validateResolvedCredentials(a);const o=s??await this.regionProvider(),c=P(t),{longDate:g,shortDate:h}=this.formatDate(e),w=j(h,o,i??this.service);c.headers[f]=g,a.sessionToken&&(c.headers[d]=a.sessionToken);const l=await x(c,this.sha256);!((t,e)=>{t=t.toLowerCase();for(const n of Object.keys(e))if(t===n.toLowerCase())return!0;return!1})(y,c.headers)&&this.applyChecksum&&(c.headers[y]=l);const m=H(c,r,n),p=await this.getSignature(g,w,this.getSigningKey(a,o,h,i),this.createCanonicalRequest(c,m,l));return c.headers[u]=`${$} Credential=${a.accessKeyId}/${w}, SignedHeaders=${this.getCanonicalHeaderList(m)}, Signature=${p}`,c}async getSignature(e,r,s,i){const a=await this.createStringToSign(e,r,i,$),o=new this.sha256(await s);return o.update(n(a)),t(await o.digest())}getSigningKey(e,n,r,s){return(async(e,n,r,s,i)=>{const a=await U(e,n.secretAccessKey,n.accessKeyId),o=`${r}:${s}:${i}:${t(a)}:${n.sessionToken}`;if(o in v)return v[o];for(S.push(o);S.length>50;)delete v[S.shift()];let c=`AWS4${n.secretAccessKey}`;for(const t of[r,s,i,A])c=await U(e,c,t);return v[o]=c})(this.sha256,e,r,n,s||this.service)}}export{q as S};
