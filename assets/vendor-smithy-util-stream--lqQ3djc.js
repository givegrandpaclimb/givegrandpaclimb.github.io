import{f as e,t}from"./vendor-smithy-util-base64-BgAHKOKZ.js";import{f as r,t as n}from"./vendor-smithy-util-utf8-MtSxxKG8.js";import{t as s}from"./vendor-smithy-util-hex-encoding-DhdgocZN.js";import{s as o}from"./vendor-smithy-fetch-http-handler-CHDfosd_.js";class a extends Uint8Array{static fromString(t,n="utf-8"){if("string"==typeof t)return function(t,n){return"base64"===n?a.mutate(e(t)):a.mutate(r(t))}(t,n);throw new Error(`Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`)}static mutate(e){return Object.setPrototypeOf(e,a.prototype),e}transformToString(e="utf-8"){return function(e,r="utf-8"){return"base64"===r?t(e):n(e)}(this,e)}}const i="function"==typeof ReadableStream?ReadableStream:function(){};class u extends i{}const c=e=>"function"==typeof ReadableStream&&(e?.constructor?.name===ReadableStream.name||e instanceof ReadableStream),f=({expectedChecksum:e,checksum:r,source:n,checksumSourceLocation:s,base64Encoder:o})=>{if(!c(n))throw new Error(`@smithy/util-stream: unsupported source type ${n?.constructor?.name??n} in ChecksumStream.`);const a=o??t;if("function"!=typeof TransformStream)throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");const i=new TransformStream({start(){},async transform(e,t){r.update(e),t.enqueue(e)},async flush(t){const n=await r.digest(),o=a(n);if(e!==o){const r=new Error(`Checksum mismatch: expected "${e}" but received "${o}" in response header "${s}".`);t.error(r)}else t.terminate()}});n.pipeThrough(i);const f=i.readable;return Object.setPrototypeOf(f,u.prototype),f};class h{constructor(e){this.allocByteArray=e,this.byteLength=0,this.byteArrays=[]}push(e){this.byteArrays.push(e),this.byteLength+=e.byteLength}flush(){if(1===this.byteArrays.length){const e=this.byteArrays[0];return this.reset(),e}const e=this.allocByteArray(this.byteLength);let t=0;for(let r=0;r<this.byteArrays.length;++r){const n=this.byteArrays[r];e.set(n,t),t+=n.byteLength}return this.reset(),e}reset(){this.byteArrays=[],this.byteLength=0}}const m=function(e,t,r){const n=e.getReader();let s=!1,o=0;const a=["",new h(e=>new Uint8Array(e))];let i=-1;const u=async e=>{const{value:c,done:f}=await n.read(),h=c;if(f){if(-1!==i){const t=l(a,i);y(t)>0&&e.enqueue(t)}e.close()}else{const n=function(e,t=!0){return t&&"undefined"!=typeof Buffer&&e instanceof Buffer?2:e instanceof Uint8Array?1:"string"==typeof e?0:-1}(h,!1);if(i!==n&&(i>=0&&e.enqueue(l(a,i)),i=n),-1===i)return void e.enqueue(h);const c=y(h);o+=c;const f=y(a[i]);if(c>=t&&0===f)e.enqueue(h);else{const n=function(e,t,r){switch(t){case 0:return e[0]+=r,y(e[0]);case 1:case 2:return e[t].push(r),y(e[t])}}(a,i,h);!s&&o>2*t&&(s=!0,r?.warn(`@smithy/util-stream - stream chunk size ${c} is below threshold of ${t}, automatically buffering.`)),n>=t?e.enqueue(l(a,i)):await u(e)}}};return new ReadableStream({pull:u})};function l(e,t){switch(t){case 0:const r=e[0];return e[0]="",r;case 1:case 2:return e[t].flush()}throw new Error(`@smithy/util-stream - invalid index ${t} given to flush()`)}function y(e){return e?.byteLength??e?.length??0}const d=(e,t)=>{const{base64Encoder:r,bodyLengthChecker:n,checksumAlgorithmFn:s,checksumLocationName:o,streamHasher:a}=t,i=void 0!==r&&void 0!==n&&void 0!==s&&void 0!==o&&void 0!==a,u=i?a(s,e):void 0,c=e.getReader();return new ReadableStream({async pull(e){const{value:t,done:s}=await c.read();if(s){if(e.enqueue("0\r\n"),i){const t=r(await u);e.enqueue(`${o}:${t}\r\n`),e.enqueue("\r\n")}e.close()}else e.enqueue(`${(n(t)||0).toString(16)}\r\n${t}\r\n`)}})};async function b(e,t){let r=0;const n=[],s=e.getReader();let o=!1;for(;!o;){const{done:e,value:a}=await s.read();if(a&&(n.push(a),r+=a?.byteLength??0),r>=t)break;o=e}s.releaseLock();const a=new Uint8Array(Math.min(t,r));let i=0;for(const u of n){if(u.byteLength>a.byteLength-i){a.set(u.subarray(0,a.byteLength-i),i);break}a.set(u,i),i+=u.length}return a}const p="The stream has already been transformed.",w=e=>{if(!g(e)&&!c(e))throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${e?.__proto__?.constructor?.name||e}`);let r=!1;const a=async()=>{if(r)throw new Error(p);return r=!0,await o(e)};return Object.assign(e,{transformToByteArray:a,transformToString:async e=>{const r=await a();if("base64"===e)return t(r);if("hex"===e)return s(r);if(void 0===e||"utf8"===e||"utf-8"===e)return n(r);if("function"==typeof TextDecoder)return new TextDecoder(e).decode(r);throw new Error("TextDecoder is not available, please make sure polyfill is provided.")},transformToWebStream:()=>{if(r)throw new Error(p);if(r=!0,g(e))return(e=>{if("function"!=typeof e.stream)throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\nIf you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");return e.stream()})(e);if(c(e))return e;throw new Error(`Cannot transform payload to web stream, got ${e}`)}})},g=e=>"function"==typeof Blob&&e instanceof Blob;async function v(e){return"function"==typeof e.stream&&(e=e.stream()),e.tee()}export{a as U,f as a,v as b,m as c,d as g,b as h,w as s};
