const t=1024;let e=0;class i{constructor(t,e){this.from=t,this.to=e}}class r{constructor(t={}){this.id=e++,this.perNode=!!t.perNode,this.deserialize=t.deserialize||(()=>{throw new Error("This node type doesn't define a deserialize function")})}add(t){if(this.perNode)throw new RangeError("Can't add per-node props to node types");return"function"!=typeof t&&(t=h.match(t)),e=>{let i=t(e);return void 0===i?null:[this,i]}}}r.closedBy=new r({deserialize:t=>t.split(" ")}),r.openedBy=new r({deserialize:t=>t.split(" ")}),r.group=new r({deserialize:t=>t.split(" ")}),r.isolate=new r({deserialize:t=>{if(t&&"rtl"!=t&&"ltr"!=t&&"auto"!=t)throw new RangeError("Invalid value for isolate: "+t);return t||"auto"}}),r.contextHash=new r({perNode:!0}),r.lookAhead=new r({perNode:!0}),r.mounted=new r({perNode:!0});class s{constructor(t,e,i){this.tree=t,this.overlay=e,this.parser=i}static get(t){return t&&t.props&&t.props[r.mounted.id]}}const n=Object.create(null);class h{constructor(t,e,i,r=0){this.name=t,this.props=e,this.id=i,this.flags=r}static define(t){let e=t.props&&t.props.length?Object.create(null):n,i=(t.top?1:0)|(t.skipped?2:0)|(t.error?4:0)|(null==t.name?8:0),r=new h(t.name||"",e,t.id,i);if(t.props)for(let s of t.props)if(Array.isArray(s)||(s=s(r)),s){if(s[0].perNode)throw new RangeError("Can't store a per-node prop on a node type");e[s[0].id]=s[1]}return r}prop(t){return this.props[t.id]}get isTop(){return(1&this.flags)>0}get isSkipped(){return(2&this.flags)>0}get isError(){return(4&this.flags)>0}get isAnonymous(){return(8&this.flags)>0}is(t){if("string"==typeof t){if(this.name==t)return!0;let e=this.prop(r.group);return!!e&&e.indexOf(t)>-1}return this.id==t}static match(t){let e=Object.create(null);for(let i in t)for(let r of i.split(" "))e[r]=t[i];return t=>{for(let i=t.prop(r.group),s=-1;s<(i?i.length:0);s++){let r=e[s<0?t.name:i[s]];if(r)return r}}}}h.none=new h("",Object.create(null),0,8);class l{constructor(t){this.types=t;for(let e=0;e<t.length;e++)if(t[e].id!=e)throw new RangeError("Node type ids should correspond to array positions when creating a node set")}extend(...t){let e=[];for(let i of this.types){let r=null;for(let e of t){let t=e(i);t&&(r||(r=Object.assign({},i.props)),r[t[0].id]=t[1])}e.push(r?new h(i.name,r,i.id,i.flags):i)}return new l(e)}}const u=new WeakMap,f=new WeakMap;var o,a;(a=o||(o={}))[a.ExcludeBuffers=1]="ExcludeBuffers",a[a.IncludeAnonymous=2]="IncludeAnonymous",a[a.IgnoreMounts=4]="IgnoreMounts",a[a.IgnoreOverlays=8]="IgnoreOverlays";class c{constructor(t,e,i,r,s){if(this.type=t,this.children=e,this.positions=i,this.length=r,this.props=null,s&&s.length){this.props=Object.create(null);for(let[t,e]of s)this.props["number"==typeof t?t:t.id]=e}}toString(){let t=s.get(this);if(t&&!t.overlay)return t.tree.toString();let e="";for(let i of this.children){let t=i.toString();t&&(e&&(e+=","),e+=t)}return this.type.name?(/\W/.test(this.type.name)&&!this.type.isError?JSON.stringify(this.type.name):this.type.name)+(e.length?"("+e+")":""):e}cursor(t=0){return new M(this.topNode,t)}cursorAt(t,e=0,i=0){let r=u.get(this)||this.topNode,s=new M(r);return s.moveTo(t,e),u.set(this,s.t),s}get topNode(){return new v(this,0,0,null)}resolve(t,e=0){let i=p(u.get(this)||this.topNode,t,e,!1);return u.set(this,i),i}resolveInner(t,e=0){let i=p(f.get(this)||this.topNode,t,e,!0);return f.set(this,i),i}resolveStack(t,e=0){return function(t,e,i){let r=t.resolveInner(e,i),n=null;for(let h=r instanceof v?r:r.context.parent;h;h=h.parent)if(h.index<0){let t=h.parent;(n||(n=[r])).push(t.resolve(e,i)),h=t}else{let t=s.get(h.tree);if(t&&t.overlay&&t.overlay[0].from<=e&&t.overlay[t.overlay.length-1].to>=e){let s=new v(t.tree,t.overlay[0].from+h.from,-1,h);(n||(n=[r])).push(p(s,e,i,!1))}}return n?m(n):r}(this,t,e)}iterate(t){let{enter:e,leave:i,from:r=0,to:s=this.length}=t,n=t.mode||0,h=(n&o.IncludeAnonymous)>0;for(let l=this.cursor(n|o.IncludeAnonymous);;){let t=!1;if(l.from<=s&&l.to>=r&&(!h&&l.type.isAnonymous||!1!==e(l))){if(l.firstChild())continue;t=!0}for(;t&&i&&(h||!l.type.isAnonymous)&&i(l),!l.nextSibling();){if(!l.parent())return;t=!0}}}prop(t){return t.perNode?this.props?this.props[t.id]:void 0:this.type.prop(t)}get propValues(){let t=[];if(this.props)for(let e in this.props)t.push([+e,this.props[e]]);return t}balance(t={}){return this.children.length<=8?this:O(h.none,this.children,this.positions,0,this.children.length,0,this.length,(t,e,i)=>new c(this.type,t,e,i,this.propValues),t.makeTree||((t,e,i)=>new c(h.none,t,e,i)))}static build(e){return function(e){var i;let{buffer:s,nodeSet:n,maxBufferLength:h=t,reused:l=[],minRepeatType:u=n.types.length}=e,f=Array.isArray(s)?new d(s,s.length):s,o=n.types,a=0,g=0;function p(t,e,i,s,d,x){let{id:S,start:m,end:C,size:M}=f,N=g,z=a;for(;M<0;){if(f.next(),-1==M){let e=l[S];return i.push(e),void s.push(m-t)}if(-3==M)return void(a=S);if(-4==M)return void(g=S);throw new RangeError(`Unrecognized record size: ${M}`)}let A,E,B=o[S],I=m-t;if(C-m<=h&&(E=function(t,e){let i=f.fork(),r=0,s=0,n=0,l=i.end-h,o={size:0,start:0,skip:0};t:for(let h=i.pos-t;i.pos>h;){let t=i.size;if(i.id==e&&t>=0){o.size=r,o.start=s,o.skip=n,n+=4,r+=4,i.next();continue}let f=i.pos-t;if(t<0||f<h||i.start<l)break;let a=i.id>=u?4:0,c=i.start;for(i.next();i.pos>f;){if(i.size<0){if(-3!=i.size)break t;a+=4}else i.id>=u&&(a+=4);i.next()}s=c,r+=t,n+=a}return(e<0||r==t)&&(o.size=r,o.start=s,o.skip=n),o.size>4?o:void 0}(f.pos-e,d))){let e=new Uint16Array(E.size-E.skip),i=f.pos-E.size,r=e.length;for(;f.pos>i;)r=y(E.start,e,r);A=new w(e,C-E.start,n),I=E.start-t}else{let t=f.pos-M;f.next();let e=[],i=[],s=S>=u?S:-1,n=0,l=C;for(;f.pos>t;)s>=0&&f.id==s&&f.size>=0?(f.end<=l-h&&(v(e,i,m,n,f.end,l,s,N,z),n=e.length,l=f.end),f.next()):x>2500?b(m,t,e,i):p(m,t,e,i,s,x+1);if(s>=0&&n>0&&n<e.length&&v(e,i,m,n,m,l,s,N,z),e.reverse(),i.reverse(),s>-1&&n>0){let t=function(t,e){return(i,s,n)=>{let h,l,u=0,f=i.length-1;if(f>=0&&(h=i[f])instanceof c){if(!f&&h.type==t&&h.length==n)return h;(l=h.prop(r.lookAhead))&&(u=s[f]+h.length+l)}return k(t,i,s,n,u,e)}}(B,z);A=O(B,e,i,0,e.length,0,C-m,t,t)}else A=k(B,e,i,C-m,N-C,z)}i.push(A),s.push(I)}function b(t,e,i,r){let s=[],l=0,u=-1;for(;f.pos>e;){let{id:t,start:e,end:i,size:r}=f;if(r>4)f.next();else{if(u>-1&&e<u)break;u<0&&(u=i-h),s.push(t,e,i),l++,f.next()}}if(l){let e=new Uint16Array(4*l),h=s[s.length-2];for(let t=s.length-3,i=0;t>=0;t-=3)e[i++]=s[t],e[i++]=s[t+1]-h,e[i++]=s[t+2]-h,e[i++]=i;i.push(new w(e,s[2]-h,n)),r.push(h-t)}}function v(t,e,i,r,s,h,l,u,f){let o=[],a=[];for(;t.length>r;)o.push(t.pop()),a.push(e.pop()+i-s);t.push(k(n.types[l],o,a,h-s,u-h,f)),e.push(s-i)}function k(t,e,i,s,n,h,l){if(h){let t=[r.contextHash,h];l=l?[t].concat(l):[t]}if(n>25){let t=[r.lookAhead,n];l=l?[t].concat(l):[t]}return new c(t,e,i,s,l)}function y(t,e,i){let{id:r,start:s,end:n,size:h}=f;if(f.next(),h>=0&&r<u){let l=i;if(h>4){let r=f.pos-(h-4);for(;f.pos>r;)i=y(t,e,i)}e[--i]=l,e[--i]=n-t,e[--i]=s-t,e[--i]=r}else-3==h?a=r:-4==h&&(g=r);return i}let x=[],S=[];for(;f.pos>0;)p(e.start||0,e.bufferStart||0,x,S,-1,0);let m=null!==(i=e.length)&&void 0!==i?i:x.length?S[0]+x[0].length:0;return new c(o[e.topID],x.reverse(),S.reverse(),m)}(e)}}c.empty=new c(h.none,[],[],0);class d{constructor(t,e){this.buffer=t,this.index=e}get id(){return this.buffer[this.index-4]}get start(){return this.buffer[this.index-3]}get end(){return this.buffer[this.index-2]}get size(){return this.buffer[this.index-1]}get pos(){return this.index}next(){this.index-=4}fork(){return new d(this.buffer,this.index)}}class w{constructor(t,e,i){this.buffer=t,this.length=e,this.set=i}get type(){return h.none}toString(){let t=[];for(let e=0;e<this.buffer.length;)t.push(this.childString(e)),e=this.buffer[e+3];return t.join(",")}childString(t){let e=this.buffer[t],i=this.buffer[t+3],r=this.set.types[e],s=r.name;if(/\W/.test(s)&&!r.isError&&(s=JSON.stringify(s)),i==(t+=4))return s;let n=[];for(;t<i;)n.push(this.childString(t)),t=this.buffer[t+3];return s+"("+n.join(",")+")"}findChild(t,e,i,r,s){let{buffer:n}=this,h=-1;for(let l=t;l!=e&&!(g(s,r,n[l+1],n[l+2])&&(h=l,i>0));l=n[l+3]);return h}slice(t,e,i){let r=this.buffer,s=new Uint16Array(e-t),n=0;for(let h=t,l=0;h<e;){s[l++]=r[h++],s[l++]=r[h++]-i;let e=s[l++]=r[h++]-i;s[l++]=r[h++]-t,n=Math.max(n,e)}return new w(s,n,this.set)}}function g(t,e,i,r){switch(t){case-2:return i<e;case-1:return r>=e&&i<e;case 0:return i<e&&r>e;case 1:return i<=e&&r>e;case 2:return r>e;case 4:return!0}}function p(t,e,i,r){for(var s;t.from==t.to||(i<1?t.from>=e:t.from>e)||(i>-1?t.to<=e:t.to<e);){let e=!r&&t instanceof v&&t.index<0?null:t.parent;if(!e)return t;t=e}let n=r?0:o.IgnoreOverlays;if(r)for(let h=t,l=h.parent;l;h=l,l=h.parent)h instanceof v&&h.index<0&&(null===(s=l.enter(e,i,n))||void 0===s?void 0:s.from)!=h.from&&(t=l);for(;;){let r=t.enter(e,i,n);if(!r)return t;t=r}}class b{cursor(t=0){return new M(this,t)}getChild(t,e=null,i=null){let r=k(this,t,e,i);return r.length?r[0]:null}getChildren(t,e=null,i=null){return k(this,t,e,i)}resolve(t,e=0){return p(this,t,e,!1)}resolveInner(t,e=0){return p(this,t,e,!0)}matchContext(t){return y(this.parent,t)}enterUnfinishedNodesBefore(t){let e=this.childBefore(t),i=this;for(;e;){let t=e.lastChild;if(!t||t.to!=e.to)break;t.type.isError&&t.from==t.to?(i=e,e=t.prevSibling):e=t}return i}get node(){return this}get next(){return this.parent}}class v extends b{constructor(t,e,i,r){super(),this.t=t,this.from=e,this.index=i,this.i=r}get type(){return this.t.type}get name(){return this.t.type.name}get to(){return this.from+this.t.length}nextChild(t,e,i,r,n=0){for(let h=this;;){for(let{children:l,positions:u}=h.t,f=e>0?l.length:-1;t!=f;t+=e){let f=l[t],a=u[t]+h.from;if(g(r,i,a,a+f.length))if(f instanceof w){if(n&o.ExcludeBuffers)continue;let s=f.findChild(0,f.buffer.length,e,i-a,r);if(s>-1)return new S(new x(h,f,t,a),null,s)}else if(n&o.IncludeAnonymous||!f.type.isAnonymous||N(f)){let l;if(!(n&o.IgnoreMounts)&&(l=s.get(f))&&!l.overlay)return new v(l.tree,a,t,h);let u=new v(f,a,t,h);return n&o.IncludeAnonymous||!u.type.isAnonymous?u:u.nextChild(e<0?f.children.length-1:0,e,i,r)}}if(n&o.IncludeAnonymous||!h.type.isAnonymous)return null;if(t=h.index>=0?h.index+e:e<0?-1:h.i.t.children.length,h=h.i,!h)return null}}get firstChild(){return this.nextChild(0,1,0,4)}get lastChild(){return this.nextChild(this.t.children.length-1,-1,0,4)}childAfter(t){return this.nextChild(0,1,t,2)}childBefore(t){return this.nextChild(this.t.children.length-1,-1,t,-2)}enter(t,e,i=0){let r;if(!(i&o.IgnoreOverlays)&&(r=s.get(this.t))&&r.overlay){let i=t-this.from;for(let{from:t,to:s}of r.overlay)if((e>0?t<=i:t<i)&&(e<0?s>=i:s>i))return new v(r.tree,r.overlay[0].from+this.from,-1,this)}return this.nextChild(0,1,t,e,i)}nextSignificantParent(){let t=this;for(;t.type.isAnonymous&&t.i;)t=t.i;return t}get parent(){return this.i?this.i.nextSignificantParent():null}get nextSibling(){return this.i&&this.index>=0?this.i.nextChild(this.index+1,1,0,4):null}get prevSibling(){return this.i&&this.index>=0?this.i.nextChild(this.index-1,-1,0,4):null}get tree(){return this.t}toTree(){return this.t}toString(){return this.t.toString()}}function k(t,e,i,r){let s=t.cursor(),n=[];if(!s.firstChild())return n;if(null!=i)for(let h=!1;!h;)if(h=s.type.is(i),!s.nextSibling())return n;for(;;){if(null!=r&&s.type.is(r))return n;if(s.type.is(e)&&n.push(s.node),!s.nextSibling())return null==r?n:[]}}function y(t,e,i=e.length-1){for(let r=t;i>=0;r=r.parent){if(!r)return!1;if(!r.type.isAnonymous){if(e[i]&&e[i]!=r.name)return!1;i--}}return!0}class x{constructor(t,e,i,r){this.parent=t,this.buffer=e,this.index=i,this.start=r}}class S extends b{get name(){return this.type.name}get from(){return this.context.start+this.context.buffer.buffer[this.index+1]}get to(){return this.context.start+this.context.buffer.buffer[this.index+2]}constructor(t,e,i){super(),this.context=t,this.i=e,this.index=i,this.type=t.buffer.set.types[t.buffer.buffer[i]]}child(t,e,i){let{buffer:r}=this.context,s=r.findChild(this.index+4,r.buffer[this.index+3],t,e-this.context.start,i);return s<0?null:new S(this.context,this,s)}get firstChild(){return this.child(1,0,4)}get lastChild(){return this.child(-1,0,4)}childAfter(t){return this.child(1,t,2)}childBefore(t){return this.child(-1,t,-2)}enter(t,e,i=0){if(i&o.ExcludeBuffers)return null;let{buffer:r}=this.context,s=r.findChild(this.index+4,r.buffer[this.index+3],e>0?1:-1,t-this.context.start,e);return s<0?null:new S(this.context,this,s)}get parent(){return this.i||this.context.parent.nextSignificantParent()}externalSibling(t){return this.i?null:this.context.parent.nextChild(this.context.index+t,t,0,4)}get nextSibling(){let{buffer:t}=this.context,e=t.buffer[this.index+3];return e<(this.i?t.buffer[this.i.index+3]:t.buffer.length)?new S(this.context,this.i,e):this.externalSibling(1)}get prevSibling(){let{buffer:t}=this.context,e=this.i?this.i.index+4:0;return this.index==e?this.externalSibling(-1):new S(this.context,this.i,t.findChild(e,this.index,-1,0,4))}get tree(){return null}toTree(){let t=[],e=[],{buffer:i}=this.context,r=this.index+4,s=i.buffer[this.index+3];if(s>r){let n=i.buffer[this.index+1];t.push(i.slice(r,s,n)),e.push(0)}return new c(this.type,t,e,this.to-this.from)}toString(){return this.context.buffer.childString(this.index)}}function m(t){if(!t.length)return null;let e=0,i=t[0];for(let n=1;n<t.length;n++){let r=t[n];(r.from>i.from||r.to<i.to)&&(i=r,e=n)}let r=i instanceof v&&i.index<0?null:i.parent,s=t.slice();return r?s[e]=r:s.splice(e,1),new C(s,i)}class C{constructor(t,e){this.heads=t,this.node=e}get next(){return m(this.heads)}}class M{get name(){return this.type.name}constructor(t,e=0){if(this.mode=e,this.buffer=null,this.stack=[],this.index=0,this.bufferNode=null,t instanceof v)this.yieldNode(t);else{this.t=t.context.parent,this.buffer=t.context;for(let e=t.i;e;e=e.i)this.stack.unshift(e.index);this.bufferNode=t,this.yieldBuf(t.index)}}yieldNode(t){return!!t&&(this.t=t,this.type=t.type,this.from=t.from,this.to=t.to,!0)}yieldBuf(t,e){this.index=t;let{start:i,buffer:r}=this.buffer;return this.type=e||r.set.types[r.buffer[t]],this.from=i+r.buffer[t+1],this.to=i+r.buffer[t+2],!0}yield(t){return!!t&&(t instanceof v?(this.buffer=null,this.yieldNode(t)):(this.buffer=t.context,this.yieldBuf(t.index,t.type)))}toString(){return this.buffer?this.buffer.buffer.childString(this.index):this.t.toString()}enterChild(t,e,i){if(!this.buffer)return this.yield(this.t.nextChild(t<0?this.t.t.children.length-1:0,t,e,i,this.mode));let{buffer:r}=this.buffer,s=r.findChild(this.index+4,r.buffer[this.index+3],t,e-this.buffer.start,i);return!(s<0)&&(this.stack.push(this.index),this.yieldBuf(s))}firstChild(){return this.enterChild(1,0,4)}lastChild(){return this.enterChild(-1,0,4)}childAfter(t){return this.enterChild(1,t,2)}childBefore(t){return this.enterChild(-1,t,-2)}enter(t,e,i=this.mode){return this.buffer?!(i&o.ExcludeBuffers)&&this.enterChild(1,t,e):this.yield(this.t.enter(t,e,i))}parent(){if(!this.buffer)return this.yieldNode(this.mode&o.IncludeAnonymous?this.t.i:this.t.parent);if(this.stack.length)return this.yieldBuf(this.stack.pop());let t=this.mode&o.IncludeAnonymous?this.buffer.parent:this.buffer.parent.nextSignificantParent();return this.buffer=null,this.yieldNode(t)}sibling(t){if(!this.buffer)return!!this.t.i&&this.yield(this.t.index<0?null:this.t.i.nextChild(this.t.index+t,t,0,4,this.mode));let{buffer:e}=this.buffer,i=this.stack.length-1;if(t<0){let t=i<0?0:this.stack[i]+4;if(this.index!=t)return this.yieldBuf(e.findChild(t,this.index,-1,0,4))}else{let t=e.buffer[this.index+3];if(t<(i<0?e.buffer.length:e.buffer[this.stack[i]+3]))return this.yieldBuf(t)}return i<0&&this.yield(this.buffer.parent.nextChild(this.buffer.index+t,t,0,4,this.mode))}nextSibling(){return this.sibling(1)}prevSibling(){return this.sibling(-1)}atLastNode(t){let e,i,{buffer:r}=this;if(r){if(t>0){if(this.index<r.buffer.buffer.length)return!1}else for(let t=0;t<this.index;t++)if(r.buffer.buffer[t+3]<this.index)return!1;({index:e,parent:i}=r)}else({index:e,i:i}=this.t);for(;i;({index:e,i:i}=i))if(e>-1)for(let r=e+t,s=t<0?-1:i.t.children.length;r!=s;r+=t){let t=i.t.children[r];if(this.mode&o.IncludeAnonymous||t instanceof w||!t.type.isAnonymous||N(t))return!1}return!0}move(t,e){if(e&&this.enterChild(t,0,4))return!0;for(;;){if(this.sibling(t))return!0;if(this.atLastNode(t)||!this.parent())return!1}}next(t=!0){return this.move(1,t)}prev(t=!0){return this.move(-1,t)}moveTo(t,e=0){for(;(this.from==this.to||(e<1?this.from>=t:this.from>t)||(e>-1?this.to<=t:this.to<t))&&this.parent(););for(;this.enterChild(1,t,e););return this}get node(){if(!this.buffer)return this.t;let t=this.bufferNode,e=null,i=0;if(t&&t.context==this.buffer)t:for(let r=this.index,s=this.stack.length;s>=0;){for(let n=t;n;n=n.i)if(n.index==r){if(r==this.index)return n;e=n,i=s+1;break t}r=this.stack[--s]}for(let r=i;r<this.stack.length;r++)e=new S(this.buffer,e,this.stack[r]);return this.bufferNode=new S(this.buffer,e,this.index)}get tree(){return this.buffer?null:this.t.t}iterate(t,e){for(let i=0;;){let r=!1;if(this.type.isAnonymous||!1!==t(this)){if(this.firstChild()){i++;continue}this.type.isAnonymous||(r=!0)}for(;;){if(r&&e&&e(this),r=this.type.isAnonymous,!i)return;if(this.nextSibling())break;this.parent(),i--,r=!0}}}matchContext(t){if(!this.buffer)return y(this.node.parent,t);let{buffer:e}=this.buffer,{types:i}=e.set;for(let r=t.length-1,s=this.stack.length-1;r>=0;s--){if(s<0)return y(this.t,t,r);let n=i[e.buffer[this.stack[s]]];if(!n.isAnonymous){if(t[r]&&t[r]!=n.name)return!1;r--}}return!0}}function N(t){return t.children.some(t=>t instanceof w||!t.type.isAnonymous||N(t))}const z=new WeakMap;function A(t,e){if(!t.isAnonymous||e instanceof w||e.type!=t)return 1;let i=z.get(e);if(null==i){i=1;for(let r of e.children){if(r.type!=t||!(r instanceof c)){i=1;break}i+=A(t,r)}z.set(e,i)}return i}function O(t,e,i,r,s,n,h,l,u){let f=0;for(let d=r;d<s;d++)f+=A(t,e[d]);let o=Math.ceil(1.5*f/8),a=[],c=[];return function e(i,r,s,h,l){for(let f=s;f<h;){let s=f,d=r[f],w=A(t,i[f]);for(f++;f<h;f++){let e=A(t,i[f]);if(w+e>=o)break;w+=e}if(f==s+1){if(w>o){let t=i[s];e(t.children,t.positions,0,t.children.length,r[s]+l);continue}a.push(i[s])}else{let e=r[f-1]+i[f-1].length-d;a.push(O(t,i,r,s,f,d,e,null,u))}c.push(d+l-n)}}(e,i,r,s,0),(l||u)(a,c,h)}class E{constructor(){this.map=new WeakMap}setBuffer(t,e,i){let r=this.map.get(t);r||this.map.set(t,r=new Map),r.set(e,i)}getBuffer(t,e){let i=this.map.get(t);return i&&i.get(e)}set(t,e){t instanceof S?this.setBuffer(t.context.buffer,t.index,e):t instanceof v&&this.map.set(t.tree,e)}get(t){return t instanceof S?this.getBuffer(t.context.buffer,t.index):t instanceof v?this.map.get(t.tree):void 0}cursorSet(t,e){t.buffer?this.setBuffer(t.buffer.buffer,t.index,e):this.map.set(t.tree,e)}cursorGet(t){return t.buffer?this.getBuffer(t.buffer.buffer,t.index):this.map.get(t.tree)}}class B{constructor(t,e,i,r,s=!1,n=!1){this.from=t,this.to=e,this.tree=i,this.offset=r,this.open=(s?1:0)|(n?2:0)}get openStart(){return(1&this.open)>0}get openEnd(){return(2&this.open)>0}static addTree(t,e=[],i=!1){let r=[new B(0,t.length,t,0,!1,i)];for(let s of e)s.to>t.length&&r.push(s);return r}static applyChanges(t,e,i=128){if(!e.length)return t;let r=[],s=1,n=t.length?t[0]:null;for(let h=0,l=0,u=0;;h++){let f=h<e.length?e[h]:null,o=f?f.fromA:1e9;if(o-l>=i)for(;n&&n.from<o;){let e=n;if(l>=e.from||o<=e.to||u){let t=Math.max(e.from,l)-u,i=Math.min(e.to,o)-u;e=t>=i?null:new B(t,i,e.tree,e.offset+u,h>0,!!f)}if(e&&r.push(e),n.to>o)break;n=s<t.length?t[s++]:null}if(!f)break;l=f.toA,u=f.toA-f.toB}return r}}class I{startParse(t,e,r){return"string"==typeof t&&(t=new T(t)),r=r?r.length?r.map(t=>new i(t.from,t.to)):[new i(0,0)]:[new i(0,t.length)],this.createParse(t,e||[],r)}parse(t,e,i){let r=this.startParse(t,e,i);for(;;){let t=r.advance();if(t)return t}}}class T{constructor(t){this.string=t}get length(){return this.string.length}chunk(t){return this.string.slice(t)}get lineChunks(){return!1}read(t,e){return this.string.slice(t,e)}}function j(t){return(e,i,r,s)=>new J(e,t,i,r,s)}class R{constructor(t,e,i,r,s){this.parser=t,this.parse=e,this.overlay=i,this.target=r,this.from=s}}function W(t){if(!t.length||t.some(t=>t.from>=t.to))throw new RangeError("Invalid inner parse ranges given: "+JSON.stringify(t))}class U{constructor(t,e,i,r,s,n,h){this.parser=t,this.predicate=e,this.mounts=i,this.index=r,this.start=s,this.target=n,this.prev=h,this.depth=0,this.ranges=[]}}const P=new r({perNode:!0});class J{constructor(t,e,i,r,s){this.nest=e,this.input=i,this.fragments=r,this.ranges=s,this.inner=[],this.innerDone=0,this.baseTree=null,this.stoppedAt=null,this.baseParse=t}advance(){if(this.baseParse){let t=this.baseParse.advance();if(!t)return null;if(this.baseParse=null,this.baseTree=t,this.startInner(),null!=this.stoppedAt)for(let e of this.inner)e.parse.stopAt(this.stoppedAt)}if(this.innerDone==this.inner.length){let t=this.baseTree;return null!=this.stoppedAt&&(t=new c(t.type,t.children,t.positions,t.length,t.propValues.concat([[P,this.stoppedAt]]))),t}let t=this.inner[this.innerDone],e=t.parse.advance();if(e){this.innerDone++;let i=Object.assign(Object.create(null),t.target.props);i[r.mounted.id]=new s(e,t.overlay,t.parser),t.target.props=i}return null}get parsedPos(){if(this.baseParse)return 0;let t=this.input.length;for(let e=this.innerDone;e<this.inner.length;e++)this.inner[e].from<t&&(t=Math.min(t,this.inner[e].parse.parsedPos));return t}stopAt(t){if(this.stoppedAt=t,this.baseParse)this.baseParse.stopAt(t);else for(let e=this.innerDone;e<this.inner.length;e++)this.inner[e].parse.stopAt(t)}startInner(){let t=new G(this.fragments),e=null,r=null,s=new M(new v(this.baseTree,this.ranges[0].from,0,null),o.IncludeAnonymous|o.IgnoreMounts);t:for(let n,h;;){let l,u=!0;if(null!=this.stoppedAt&&s.from>=this.stoppedAt)u=!1;else if(t.hasNode(s)){if(e){let t=e.mounts.find(t=>t.frag.from<=s.from&&t.frag.to>=s.to&&t.mount.overlay);if(t)for(let i of t.mount.overlay){let r=i.from+t.pos,n=i.to+t.pos;r>=s.from&&n<=s.to&&!e.ranges.some(t=>t.from<n&&t.to>r)&&e.ranges.push({from:r,to:n})}}u=!1}else if(r&&(h=L(r.ranges,s.from,s.to)))u=2!=h;else if(!s.type.isAnonymous&&(n=this.nest(s,this.input))&&(s.from<s.to||!n.overlay)){s.tree||D(s);let h=t.findMounts(s.from,n.parser);if("function"==typeof n.overlay)e=new U(n.parser,n.overlay,h,this.inner.length,s.from,s.tree,e);else{let t=V(this.ranges,n.overlay||(s.from<s.to?[new i(s.from,s.to)]:[]));t.length&&W(t),!t.length&&n.overlay||this.inner.push(new R(n.parser,t.length?n.parser.startParse(this.input,q(h,t),t):n.parser.startParse(""),n.overlay?n.overlay.map(t=>new i(t.from-s.from,t.to-s.from)):null,s.tree,t.length?t[0].from:s.from)),n.overlay?t.length&&(r={ranges:t,depth:0,prev:r}):u=!1}}else if(e&&(l=e.predicate(s))&&(!0===l&&(l=new i(s.from,s.to)),l.from<l.to)){let t=e.ranges.length-1;t>=0&&e.ranges[t].to==l.from?e.ranges[t]={from:e.ranges[t].from,to:l.to}:e.ranges.push(l)}if(u&&s.firstChild())e&&e.depth++,r&&r.depth++;else for(;!s.nextSibling();){if(!s.parent())break t;if(e&&! --e.depth){let t=V(this.ranges,e.ranges);t.length&&(W(t),this.inner.splice(e.index,0,new R(e.parser,e.parser.startParse(this.input,q(e.mounts,t),t),e.ranges.map(t=>new i(t.from-e.start,t.to-e.start)),e.target,t[0].from))),e=e.prev}r&&! --r.depth&&(r=r.prev)}}}}function L(t,e,i){for(let r of t){if(r.from>=i)break;if(r.to>e)return r.from<=e&&r.to>=i?2:1}return 0}function _(t,e,i,r,s,n){if(e<i){let h=t.buffer[e+1];r.push(t.slice(e,i,h)),s.push(h-n)}}function D(t){let{node:e}=t,i=[],r=e.context.buffer;do{i.push(t.index),t.parent()}while(!t.tree);let s=t.tree,n=s.children.indexOf(r),l=s.children[n],u=l.buffer,f=[n];s.children[n]=function t(r,s,n,h,o,a){let d=i[a],w=[],g=[];_(l,r,d,w,g,h);let p=u[d+1],b=u[d+2];f.push(w.length);let v=a?t(d+4,u[d+3],l.set.types[u[d]],p,b-p,a-1):e.toTree();return w.push(v),g.push(p-h),_(l,u[d+3],s,w,g,h),new c(n,w,g,o)}(0,u.length,h.none,0,l.length,i.length-1);for(let h of f){let e=t.tree.children[h],i=t.tree.positions[h];t.yield(new v(e,i+t.from,h,t.t))}}class F{constructor(t,e){this.offset=e,this.done=!1,this.cursor=t.cursor(o.IncludeAnonymous|o.IgnoreMounts)}moveTo(t){let{cursor:e}=this,i=t-this.offset;for(;!this.done&&e.from<i;)e.to>=t&&e.enter(i,1,o.IgnoreOverlays|o.ExcludeBuffers)||e.next(!1)||(this.done=!0)}hasNode(t){if(this.moveTo(t.from),!this.done&&this.cursor.from+this.offset==t.from&&this.cursor.tree)for(let e=this.cursor.tree;;){if(e==t.tree)return!0;if(!(e.children.length&&0==e.positions[0]&&e.children[0]instanceof c))break;e=e.children[0]}return!1}}class G{constructor(t){var e;if(this.fragments=t,this.curTo=0,this.fragI=0,t.length){let i=this.curFrag=t[0];this.curTo=null!==(e=i.tree.prop(P))&&void 0!==e?e:i.to,this.inner=new F(i.tree,-i.offset)}else this.curFrag=this.inner=null}hasNode(t){for(;this.curFrag&&t.from>=this.curTo;)this.nextFrag();return this.curFrag&&this.curFrag.from<=t.from&&this.curTo>=t.to&&this.inner.hasNode(t)}nextFrag(){var t;if(this.fragI++,this.fragI==this.fragments.length)this.curFrag=this.inner=null;else{let e=this.curFrag=this.fragments[this.fragI];this.curTo=null!==(t=e.tree.prop(P))&&void 0!==t?t:e.to,this.inner=new F(e.tree,-e.offset)}}findMounts(t,e){var i;let s=[];if(this.inner){this.inner.cursor.moveTo(t,1);for(let t=this.inner.cursor.node;t;t=t.parent){let n=null===(i=t.tree)||void 0===i?void 0:i.prop(r.mounted);if(n&&n.parser==e)for(let e=this.fragI;e<this.fragments.length;e++){let i=this.fragments[e];if(i.from>=t.to)break;i.tree==this.curFrag.tree&&s.push({frag:i,pos:t.from-i.offset,mount:n})}}}return s}}function V(t,e){let r=null,s=e;for(let n=1,h=0;n<t.length;n++){let l=t[n-1].to,u=t[n].from;for(;h<s.length;h++){let t=s[h];if(t.from>=u)break;t.to<=l||(r||(s=r=e.slice()),t.from<l?(r[h]=new i(t.from,l),t.to>u&&r.splice(h+1,0,new i(u,t.to))):t.to>u?r[h--]=new i(u,t.to):r.splice(h--,1))}}return s}function $(t,e,r,s){let n=0,h=0,l=!1,u=!1,f=-1e9,o=[];for(;;){let a=n==t.length?1e9:l?t[n].to:t[n].from,c=h==e.length?1e9:u?e[h].to:e[h].from;if(l!=u){let t=Math.max(f,r),e=Math.min(a,c,s);t<e&&o.push(new i(t,e))}if(f=Math.min(a,c),1e9==f)break;a==f&&(l?(l=!1,n++):l=!0),c==f&&(u?(u=!1,h++):u=!0)}return o}function q(t,e){let r=[];for(let{pos:s,mount:n,frag:h}of t){let t=s+(n.overlay?n.overlay[0].from:0),l=t+n.tree.length,u=Math.max(h.from,t),f=Math.min(h.to,l);if(n.overlay){let l=$(e,n.overlay.map(t=>new i(t.from+s,t.to+s)),u,f);for(let e=0,i=u;;e++){let s=e==l.length,u=s?f:l[e].from;if(u>i&&r.push(new B(i,u,n.tree,-t,h.from>=i||h.openStart,h.to<=u||h.openEnd)),s)break;i=l[e].to}}else r.push(new B(u,f,n.tree,-t,h.from>=t||h.openStart,h.to<=l||h.openEnd))}return r}export{t as D,o as I,r as N,I as P,c as T,E as a,h as b,B as c,l as d,j as p};
